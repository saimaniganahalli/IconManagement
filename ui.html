<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Icon Management</title>
    
    <!-- Google Fonts - Poppins -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <!-- JSZip for creating zip files -->
    <script src="https://unpkg.com/jszip@latest/dist/jszip.min.js"></script>
    

    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', system-ui, sans-serif;
            font-size: 12px;
            line-height: 1.4;
            color: #1d1d1d;
            background: #ffffff;
            -webkit-font-smoothing: antialiased;
            letter-spacing: -0.25px;
        }

        .container {
            width: 800px;
            height: 800px;
            display: flex;
            flex-direction: column;
            background: #ffffff;
            position: relative;
        }

        /* Plugin Header */
        .plugin-header {
            padding: 20px 20px 16px 20px;
            background: #ffffff;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
        }

        .plugin-title {
            flex: 1;
        }

        .plugin-title h1 {
            font-size: 20px;
            font-weight: 600;
            color: #1d1d1d;
            margin: 0 0 4px 0;
            letter-spacing: -0.25px;
        }

        .plugin-title p {
            font-size: 13px;
            color: #666;
            margin: 0;
            font-weight: 400;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .scan-button.primary {
            padding: 8px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
            letter-spacing: -0.25px;
            font-family: 'Poppins', sans-serif;
        }

        .scan-button.primary:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .scan-button.primary:active {
            transform: translateY(0);
        }

        .scan-button.primary:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Search Section */
        .search-section {
            padding: 16px 20px;
            background: #ffffff;
            border-bottom: 1px solid #f0f0f0;
        }

        .search-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }



        .settings-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            color: #666;
            transition: all 0.2s;
            margin-left: 8px;
        }

        .settings-button:hover {
            background-color: #f8f9fa;
            color: #333;
        }

        .search-input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            background: #ffffff;
            transition: border-color 0.2s;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.25px;
        }

        .search-input:focus {
            border-color: #000000;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
        }

        .add-button {
            padding: 10px 16px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.25px;
        }

        .add-button:hover {
            background: #0052a3;
        }

        .add-button:disabled {
            background: #d4d4d4;
            cursor: not-allowed;
        }

        .view-toggle {
            display: flex;
            gap: 4px;
        }

        .view-button {
            padding: 8px 16px;
            background: transparent;
            border: none;
            font-size: 13px;
            cursor: pointer;
            color: #666;
            transition: all 0.2s;
            border-radius: 6px;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            letter-spacing: -0.25px;
        }

        .view-button:hover {
            background: #f8f9fa;
            color: #333;
        }

        .view-button.active {
            background: #f0f0f0;
            color: #000;
            font-weight: 500;
        }

        /* Scan Results */
        .scan-results {
            padding: 16px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #f0f0f0;
        }



        .result-stats {
            display: flex;
            gap: 24px;
            margin-bottom: 16px;
            font-size: 13px;
        }

        .stat {
            color: #666;
        }

        .stat-value {
            font-weight: 600;
            color: #1d1d1d;
            margin-right: 4px;
        }

        .scan-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .scan-button {
            padding: 8px 16px;
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.25px;
        }

        .scan-button:hover {
            background: #5a5f6b;
        }

        .scan-button.active {
            background: #3b82f6;
        }

        .scan-button.active:hover {
            background: #2563eb;
        }

        /* Progress in Scan Results */
        .scan-results .progress {
            height: 2px;
            background: #e6e6e6;
            margin: 16px 0 0 0;
            display: none;
            border-radius: 1px;
        }

        .scan-results .progress.show {
            display: block;
        }

        .scan-results .progress-bar {
            height: 100%;
            background: #3b82f6;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 1px;
        }

        /* Status Bar */
        .status-bar {
            padding: 12px 0;
            background: #f0f8ff;
            border-radius: 6px;
            margin-top: 8px;
            font-size: 11px;
            color: #666;
            display: none;
            text-align: center;
        }

        .status-bar.show {
            display: block;
        }

        .status-bar.error {
            background: #fff5f5;
            color: #d73a49;
        }

        .status-bar.success {
            background: #f0fff4;
            color: #28a745;
        }

        .status-bar.warning {
            background: #fffbeb;
            color: #d97706;
        }

        /* Main Content */
        .content {
            flex: 1;
            display: flex;
            overflow: hidden;
            margin-bottom: 32px; /* Account for footer height */
        }

        /* Icon Grid */
        .icon-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            min-height: 0; /* Allow flex child to shrink */
            background: #ffffff;
        }

        /* Better split view when details panel is open */
        .content.with-details .icon-area {
            flex: 1;
            padding: 16px 12px 20px 20px; /* Reduced right padding for more space */
            max-height: 100%;
        }

        .empty-state {
            text-align: center;
            color: #999;
            margin-top: 60px;
        }

        .empty-state h3 {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            color: #666;
        }

        .empty-state p {
            font-size: 11px;
            line-height: 1.4;
        }

        .icon-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
        }
        
        /* Adjust grid spacing in split view for better density */
        .content.with-details .icon-grid {
            grid-template-columns: repeat(auto-fill, minmax(56px, 1fr));
            gap: 6px;
        }

        /* Page sections */
        .page-section {
            margin-bottom: 24px;
        }

        .page-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 0 12px 0;
            margin-bottom: 16px;
            border-bottom: 1px solid #f5f5f5;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease;
        }
        
        .page-header:hover {
            background-color: #f8f9fa;
        }

        .page-title {
            font-size: 15px;
            font-weight: 600;
            color: #000;
        }

        .page-count {
            font-size: 12px;
            color: #666;
            background: #f8f9fa;
            padding: 4px 8px;
            border-radius: 12px;
        }

        .page-toggle {
            font-size: 14px;
            color: #666;
            transition: transform 0.2s ease;
            font-weight: bold;
        }

        .page-section.collapsed .page-toggle {
            transform: rotate(-90deg);
        }

        .page-section.collapsed .page-content {
            display: none;
        }

        .page-content {
            transition: all 0.2s ease;
        }

        .icon-slot {
            width: 60px;
            height: 60px;
            border: 1px solid #f0f0f0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: #ffffff;
            transition: all 0.2s;
        }
        
        /* Optimize icon slots in split view */
        .content.with-details .icon-slot {
            width: 56px;
            height: 56px;
            border-radius: 6px;
        }

        .icon-slot:hover {
            border-color: #e0e0e0;
            background: #fafafa;
        }

        .icon-slot.filled {
            border: 1px solid #f0f0f0;
            background: #ffffff;
        }

        .icon-slot.filled:hover {
            border-color: #000000;
        }

        .icon-slot.selected {
            border-color: #000000;
            background: #f8f9fa;
        }

        /* Status indicators - minimal dots instead of borders */
        .icon-slot.status-unresolved::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 6px;
            height: 6px;
            background: #f59e0b;
            border-radius: 50%;
        }

        .icon-slot.status-instance::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 6px;
            height: 6px;
            background: #10b981;
            border-radius: 50%;
        }

        .icon-slot.status-master::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 6px;
            height: 6px;
            background: #8b5cf6;
            border-radius: 50%;
        }

        /* Tags for new and duplicate icons */
        .icon-slot {
            position: relative;
        }

        .icon-tag {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #dc2626;
            color: white;
            font-size: 8px;
            font-weight: 600;
            padding: 2px 4px;
            border-radius: 6px;
            text-transform: uppercase;
            z-index: 10;
        }

        .icon-tag.new {
            background: #0066cc;
        }

        .icon-tag.duplicate {
            background: #f59e0b;
            color: #000;
        }

        .icon-tag.variants {
            background: #8b5cf6;
            color: white;
        }

        /* Stack multiple tags */
        .icon-tag + .icon-tag {
            right: -6px;
            top: 8px;
        }

        /* Status legend */
        .status-legend {
            padding: 12px 20px;
            background: #ffffff;
            border-bottom: 1px solid #f0f0f0;
            font-size: 12px;
            display: none;
        }

        .status-legend.show {
            display: block;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 4px;
            color: #666;
        }

        .legend-color {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .legend-color.orange { background-color: #f59e0b; }
        .legend-color.purple { background-color: #8b5cf6; }
        .legend-color.green { background-color: #10b981; }
        
        /* Hover tooltip */
        .icon-slot {
            position: relative;
        }

        .icon-slot .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1d1d1d;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
            margin-bottom: 4px;
        }

        .icon-slot:hover .tooltip {
            opacity: 1;
        }

        .add-icon-slot {
            color: #999;
            font-size: 20px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        
        .icon-slot:hover .add-icon-slot {
            color: #3b82f6;
            background-color: #f0f8ff;
            transform: scale(1.1);
        }

        /* Icon Details Panel */
        .details-panel {
            width: 260px; /* Slightly narrower for better proportions */
            border-left: 1px solid #e5e5e5;
            background: #fafbfc; /* Subtle background difference */
            padding: 20px 16px 20px 20px; /* Optimized padding */
            overflow-y: auto;
            display: none;
            flex-shrink: 0; /* Don't shrink */
            height: 100%; /* Take full height */
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.02); /* Subtle depth */
        }

        .details-panel.show {
            display: block;
        }

        .icon-name {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #1d1d1d;
            line-height: 1.3;
            word-break: break-word; /* Handle long names gracefully */
        }
        
        /* Details panel header styling */
        .details-panel .close-button {
            background: rgba(0, 0, 0, 0.05);
            border: none;
            border-radius: 6px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #666;
            font-size: 14px;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .details-panel .close-button:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #333;
        }

        .icon-actions {
            margin-bottom: 16px;
        }

        .swap-button {
            padding: 8px 16px;
            background: #0066cc;
            color: white;
            border: 1px solid #0066cc;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            width: 100%;
            box-shadow: 0 1px 3px rgba(0, 102, 204, 0.2);
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.25px;
        }

        .swap-button:hover {
            background: #0052a3;
            border-color: #0052a3;
        }

        .swap-button:active {
            transform: translateY(1px);
        }

        .swap-button:disabled {
            background: #f5f5f5;
            color: #ccc;
            cursor: not-allowed;
            border-color: #e5e5e5;
        }

        /* Variant Selector */
        .variant-selector {
            margin-bottom: 16px;
            background: #f8f9fa;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 12px;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            min-width: 180px;
            padding: 4px 0;
            display: none;
        }

        .context-menu-item {
            padding: 8px 12px;
            font-size: 12px;
            color: #333;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: #f8f9fa;
        }

        .context-menu-item.disabled {
            color: #999;
            cursor: not-allowed;
        }

        .context-menu-item.disabled:hover {
            background: transparent;
        }

        .context-menu-separator {
            height: 1px;
            background: #e5e5e5;
            margin: 4px 0;
        }

        .variant-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .variant-title {
            font-size: 12px;
            font-weight: 600;
            color: #1d1d1d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .variant-count {
            font-size: 10px;
            color: #666;
            background: #ffffff;
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid #e5e5e5;
        }

        .variant-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .variant-tab {
            width: 32px;
            height: 32px;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            cursor: pointer;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .variant-tab:hover {
            border-color: #000000;
            background: #f8f9fa;
        }

        .variant-tab.active {
            border-color: #000000;
            background: #f0f8ff;
            box-shadow: 0 0 0 2px rgba(0, 102, 204, 0.2);
        }

        .variant-tab img {
            max-width: 24px;
            max-height: 24px;
            object-fit: contain;
        }

        .variant-tab .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1d1d1d;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
            margin-bottom: 4px;
        }

        .variant-tab:hover .tooltip {
            opacity: 1;
        }

        .icon-status {
            margin-bottom: 16px;
            padding: 8px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 3px;
            font-size: 11px;
            color: #856404;
        }

        .icon-status a {
            color: #0066cc;
            text-decoration: none;
        }

        .icon-status a:hover {
            text-decoration: underline;
        }

        .icon-status.master-status {
            background: #f0fff4;
            border-color: #10b981;
            color: #047857;
        }

        .icon-status.instance-status {
            background: #faf5ff;
            border-color: #8b5cf6;
            color: #7c3aed;
        }

        .icon-status.unresolved-status {
            background: #fffbeb;
            border-color: #f59e0b;
            color: #d97706;
        }

        .icon-preview {
            margin-bottom: 16px;
            text-align: center;
        }

        .preview-box {
            width: 100px;
            height: 100px;
            border: 1px dashed #d4d4d4;
            border-radius: 8px;
            margin: 0 auto 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .icon-size {
            font-size: 10px;
            color: #999;
        }

        .icon-info {
            border-top: 1px solid #e6e6e6;
            padding-top: 12px;
        }

        .info-item {
            margin-bottom: 10px; /* Slightly more space */
        }

        .info-item:last-child {
            margin-bottom: 0; /* Remove bottom margin from last item */
        }

        .info-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 3px; /* Slightly more space */
            font-weight: 500;
        }

        .info-value {
            font-size: 11px;
            color: #1d1d1d;
            line-height: 1.3;
            word-break: break-word; /* Handle long values gracefully */
        }

        /* Progress Indicator */
        .progress {
            height: 2px;
            background: #e6e6e6;
            margin: 16px 0 0 0;
            display: none;
        }

        .progress.show {
            display: block;
        }

        .progress-bar {
            height: 100%;
            background: #0066cc;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Scan Results */
        .scan-results {
            padding: 20px 20px 20px 20px;
            background: #ffffff;
            border-bottom: 1px solid #f0f0f0;
            font-size: 13px;
            display: none;
        }

        .scan-results.show {
            display: block;
        }

        .result-stats {
            display: flex;
            gap: 24px;
            margin-bottom: 16px;
            font-size: 13px;
        }

        .stat {
            color: #666;
        }

        .stat-value {
            font-weight: 600;
            color: #000;
            margin-right: 4px;
        }

        .scan-actions {
            display: flex;
            gap: 8px;
        }

        .action-button {
            padding: 8px 16px;
            background: #f8f9fa;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
            color: #333;
            transition: all 0.2s;
            white-space: nowrap;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.25px;
        }

        .action-button:hover {
            background: #f0f0f0;
            border-color: rgba(0, 0, 0, 0.15);
        }

        .action-button.primary {
            background: #000000;
            color: white;
            border-color: rgba(0, 0, 0, 0.2);
        }

        .action-button.primary:hover {
            background: #333333;
            border-color: rgba(0, 0, 0, 0.3);
        }

        .action-button:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
            border-color: rgba(0, 0, 0, 0.05);
        }

        /* List View */
        .icon-list {
            display: none;
        }

        .icon-list.show {
            display: block;
        }

        .list-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
        }

        .list-item:hover {
            background: #f8f9fa;
        }

        .list-item.selected {
            background: #f0f8ff;
            border-color: #0066cc;
        }

        .list-icon {
            width: 24px;
            height: 24px;
            border: 1px solid #e6e6e6;
            border-radius: 2px;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .list-name {
            font-size: 12px;
            color: #1d1d1d;
        }

        /* Keyboard Focus */
        .search-input:focus,
        .add-button:focus,
        .view-button:focus,
        .swap-button:focus,
        .action-button:focus {
            outline: 2px solid #0066cc;
            outline-offset: 1px;
        }

        /* Confirmation Dialog */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .dialog-overlay.show {
            display: flex;
        }

        .dialog {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            width: 480px;
            max-width: 90vw;
            max-height: 80vh;
            overflow: hidden;
        }

        .dialog-header {
            padding: 24px 24px 16px 24px;
            border-bottom: 1px solid #f0f0f0;
        }

        .dialog-title {
            font-size: 18px;
            font-weight: 600;
            color: #1d1d1d;
            margin-bottom: 8px;
        }

        .dialog-subtitle {
            font-size: 14px;
            color: #666;
            line-height: 1.4;
        }

        .dialog-hint {
            display: flex;
            align-items: center;
            margin-top: 12px;
            padding: 8px 12px;
            background: #f0f8ff;
            border: 1px solid #e0f2fe;
            border-radius: 6px;
            font-size: 11px;
            color: #0369a1;
            animation: fadeInHint 0.5s ease-out;
        }

        @keyframes fadeInHint {
            from {
                opacity: 0;
                transform: translateY(-4px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dialog-content {
            padding: 20px 24px;
        }

        .scope-options {
            margin-bottom: 20px;
        }

        .scope-option {
            display: flex;
            align-items: flex-start;
            padding: 12px;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .scope-option:hover {
            border-color: #000000;
            background: #f8f9fa;
        }

        .scope-option.selected {
            border-color: #000000;
            background: #f0f8ff;
        }

        .scope-radio {
            width: 16px;
            height: 16px;
            border: 2px solid #e5e5e5;
            border-radius: 50%;
            margin-right: 12px;
            margin-top: 2px;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .scope-option.selected .scope-radio {
            border-color: #000000;
            background: #000000;
            position: relative;
        }

        .scope-option.selected .scope-radio::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .scope-info {
            flex: 1;
        }

        .scope-title {
            font-size: 14px;
            font-weight: 500;
            color: #1d1d1d;
            margin-bottom: 4px;
        }

        .scope-description {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
        }

        .impact-summary {
            background: #f8f9fa;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .impact-title {
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1d;
            margin-bottom: 8px;
        }

        .impact-stats {
            display: flex;
            gap: 16px;
            font-size: 12px;
        }

        .impact-stat {
            color: #666;
        }

        .impact-value {
            font-weight: 600;
            color: #000;
        }

        .dialog-actions {
            padding: 16px 24px 24px 24px;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .dialog-button {
            padding: 8px 20px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.25px;
        }

        .dialog-button.secondary {
            background: #f8f9fa;
            color: #333; /* Darker text for better contrast on light background */
            border-color: rgba(0, 0, 0, 0.1);
        }

        .dialog-button.secondary:hover {
            background: #f0f0f0;
            border-color: rgba(0, 0, 0, 0.15);
            color: #1d1d1d; /* Even darker on hover for better contrast */
        }

        .dialog-button.primary {
            background: #000000;
            color: white;
            border-color: rgba(0, 0, 0, 0.2);
        }

        .dialog-button.primary:hover {
            background: #333333;
        }

        .dialog-button:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
            border-color: rgba(0, 0, 0, 0.05);
        }

        /* Success Dialog */
        .success-dialog {
            background: #f0fff4;
            border: 1px solid #10b981;
        }

        .success-dialog .dialog-header {
            border-bottom-color: #d1fae5;
        }

        .success-dialog .dialog-title {
            color: #065f46;
        }

        .success-dialog .dialog-subtitle {
            color: #059669;
        }

        .refresh-prompt {
            background: #ffffff;
            border: 1px solid #10b981;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .refresh-prompt-title {
            font-size: 14px;
            font-weight: 600;
            color: #065f46;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .refresh-prompt-title::before {
            content: "✨";
            font-size: 16px;
        }

        .refresh-prompt-text {
            font-size: 13px;
            color: #047857;
            line-height: 1.4;
            margin-bottom: 12px;
        }

        .refresh-actions {
            display: flex;
            gap: 8px;
        }

        .refresh-button {
            padding: 8px 16px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.25px;
        }

        .refresh-button:hover {
            background: #059669;
        }

        .refresh-button.secondary {
            background: transparent;
            color: #047857;
            border: 1px solid #10b981;
        }

        .refresh-button.secondary:hover {
            background: #f0fff4;
        }

        /* Icon Swap Dialog */
        .swap-dialog {
            width: 760px;
            max-width: 95vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .swap-dialog .dialog-content {
            flex: 1;
            overflow-y: auto;
            max-height: calc(90vh - 140px);
        }

        .swap-preview {
            display: flex;
            align-items: center;
            gap: 24px;
            margin-bottom: 24px;
            padding: 24px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e5e5e5;
        }

        .swap-section {
            flex: 1;
            text-align: center;
        }

        .swap-section-title {
            font-size: 12px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 16px;
        }

        .swap-icon-preview {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .swap-icon-image {
            width: 88px;
            height: 88px;
            border: 2px solid #e5e5e5;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #ffffff;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .swap-icon-image img {
            max-width: 72px;
            max-height: 72px;
            object-fit: contain;
        }

        .swap-placeholder {
            font-size: 11px;
            color: #999;
            text-align: center;
            line-height: 1.3;
            padding: 8px;
        }

        .swap-icon-name {
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1d;
            max-width: 120px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .swap-icon-details {
            font-size: 11px;
            color: #666;
            max-width: 120px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .swap-arrow {
            font-size: 28px;
            color: #666;
            font-weight: 300;
            flex-shrink: 0;
            background: #ffffff;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #e5e5e5;
            cursor: pointer;
            transition: all 0.2s ease, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            z-index: 10;
        }

        .swap-arrow:hover {
            background: #f0f8ff;
            border-color: #3b82f6;
            color: #3b82f6;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }

        .swap-arrow:active {
            transform: scale(0.95);
        }

        .swap-content-section {
            margin-bottom: 24px;
        }

        .swap-content-section:last-child {
            margin-bottom: 0;
        }

        .swap-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .swap-section-title-main {
            font-size: 14px;
            font-weight: 600;
            color: #1d1d1d;
        }

        .swap-section-description {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
            margin-bottom: 16px;
        }

        .swap-search {
            margin-bottom: 16px;
        }

        .swap-search-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
            background: #ffffff;
        }

        .swap-search-input:focus {
            border-color: #000000;
        }

        .swap-search-input::placeholder {
            color: #999;
        }

        .swap-icon-grid-container {
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            background: #ffffff;
            overflow: hidden;
        }

        .swap-icon-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 8px;
            max-height: 280px;
            overflow-y: auto;
            padding: 16px;
        }

        .swap-icon-grid::-webkit-scrollbar {
            width: 8px;
        }

        .swap-icon-grid::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .swap-icon-grid::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .swap-icon-grid::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .swap-grid-status {
            padding: 12px 16px;
            background: #f8f9fa;
            border-bottom: 1px solid #e5e5e5;
            font-size: 12px;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .swap-grid-legend {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 11px;
            color: #666;
        }

        .swap-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .swap-icon-slot {
            width: 64px;
            height: 64px;
            border: 2px solid #f0f0f0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: #ffffff;
            transition: all 0.2s;
            position: relative;
        }

        .swap-icon-slot:hover {
            border-color: #000000;
            background: #f8f9fa;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .swap-icon-slot.selected {
            border-color: #000000;
            background: #f0f8ff;
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.2);
            transform: translateY(-1px);
        }

        .swap-icon-slot img {
            max-width: 52px;
            max-height: 52px;
            object-fit: contain;
        }

        .swap-icon-slot .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1d1d1d;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
            margin-bottom: 6px;
            max-width: 200px;
            white-space: normal;
            text-align: center;
        }

        .swap-icon-slot:hover .tooltip {
            opacity: 1;
        }

        .swap-icon-slot.needs-conversion {
            border-color: #0ea5e9;
            background: #f0f9ff;
        }

        .swap-icon-slot.needs-conversion:hover {
            border-color: #0284c7;
            background: #e0f2fe;
        }

        .swap-status-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 20px;
            height: 20px;
            background: #f59e0b;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .swap-status-badge.component {
            background: #10b981;
        }

        .swap-empty-state {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }

        .swap-empty-state h4 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .swap-empty-state p {
            font-size: 12px;
            line-height: 1.4;
            color: #666;
        }

        .swap-impact {
            background: #f8f9fa;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 16px;
        }

        .swap-impact .impact-title {
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1d;
            margin-bottom: 8px;
        }

        .swap-impact .impact-stats {
            display: flex;
            gap: 16px;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .swap-impact .impact-stat {
            color: #666;
        }

        .swap-impact .impact-value {
            font-weight: 600;
            color: #000;
        }

        /* Swap Sizing Controls */
        .swap-sizing {
            background: #fff8dc;
            border: 1px solid #f4c842;
            border-radius: 8px;
            padding: 20px;
        }

        .sizing-title {
            font-size: 14px;
            font-weight: 600;
            color: #856404;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sizing-comparison {
            display: flex;
            gap: 32px;
            margin-bottom: 20px;
            justify-content: center;
            padding: 16px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 8px;
        }

        .size-info {
            text-align: center;
        }

        .size-label {
            font-size: 12px;
            color: #666;
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
        }

        .size-value {
            font-size: 16px;
            font-weight: 700;
            color: #333;
            display: block;
        }

        .sizing-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .sizing-option {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
            padding: 12px;
            border-radius: 8px;
            transition: background-color 0.2s;
            border: 1px solid transparent;
        }

        .sizing-option:hover {
            background: rgba(244, 200, 66, 0.15);
            border-color: rgba(244, 200, 66, 0.3);
        }

        .sizing-option input[type="radio"] {
            margin-top: 3px;
            width: 16px;
            height: 16px;
        }

        .sizing-option-text {
            flex: 1;
        }

        .sizing-option-text strong {
            display: block;
            font-size: 13px;
            color: #333;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .sizing-option-text {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
        }

        /* Swap Conversion Notice */
        .swap-conversion {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .conversion-notice {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .conversion-icon {
            font-size: 20px;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .conversion-text {
            flex: 1;
        }

        .conversion-title {
            font-size: 13px;
            font-weight: 600;
            color: #0c4a6e;
            margin-bottom: 4px;
        }

        .conversion-description {
            font-size: 12px;
            color: #075985;
            line-height: 1.4;
        }

        /* Duplicate Consolidation Banner */
        .duplicate-banner {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .duplicate-banner-content {
            flex: 1;
        }

        .duplicate-banner-title {
            font-size: 13px;
            font-weight: 600;
            color: #856404;
            margin-bottom: 4px;
        }

        .duplicate-banner-text {
            font-size: 12px;
            color: #856404;
            line-height: 1.4;
        }

        .duplicate-banner-button {
            padding: 8px 16px;
            background: #f59e0b;
            color: #1d1d1d; /* Dark text for better contrast on orange background */
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.25px;
        }

        .duplicate-banner-button:hover {
            background: #d97706;
            color: #1d1d1d; /* Maintain dark text on hover for contrast */
        }

        .duplicate-banner-button:disabled {
            background: #d4d4d4;
            cursor: not-allowed;
        }

        /* Onboarding Overlay */
        .onboarding-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(4px);
            display: none;
            z-index: 10000;
            transition: all 0.3s ease;
        }

        .onboarding-overlay.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .onboarding-step {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 520px;
            width: 90%;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
            text-align: center;
            position: relative;
            animation: slideUp 0.5s ease-out;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .onboarding-step h2 {
            font-size: 28px;
            font-weight: 700;
            color: #1d1d1d;
            margin-bottom: 16px;
            line-height: 1.2;
        }

        .onboarding-step p {
            font-size: 16px;
            color: #666;
            line-height: 1.6;
            margin-bottom: 32px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .onboarding-visual {
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 32px auto;
            font-size: 48px;
            color: white;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.4);
        }

        .onboarding-actions {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-top: 32px;
        }

        .onboarding-button {
            padding: 8px 28px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            min-width: 120px;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.25px;
        }

        .onboarding-button.primary {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.4);
        }

        .onboarding-button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(59, 130, 246, 0.5);
        }

        .onboarding-button.secondary {
            background: white;
            color: #666;
            border-color: #e0e0e0;
        }

        .onboarding-button.secondary:hover {
            background: #f8f9fa;
            border-color: #d0d0d0;
        }

        .onboarding-progress {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 13px;
            color: #999;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: 500;
        }

        .onboarding-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            font-size: 20px;
            color: #666;
            cursor: pointer;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
            font-weight: 300;
        }

        .onboarding-close:hover {
            background: white;
            color: #333;
            border-color: rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .settings-modal.show {
            display: flex;
        }

        .settings-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            width: 400px;
            max-width: 90vw;
            box-shadow: 0 20px 40px rgba(0, 0, 1, 0.15);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .settings-title {
            font-size: 18px;
            font-weight: 600;
            color: #1d1d1d;
        }

        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .settings-option:last-child {
            border-bottom: none;
        }

        .settings-option-info {
            flex: 1;
        }

        .settings-option-title {
            font-size: 14px;
            font-weight: 500;
            color: #1d1d1d;
            margin-bottom: 4px;
        }

        .settings-option-description {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
        }

        .settings-button-action {
            padding: 8px 16px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Poppins', sans-serif;
            letter-spacing: -0.25px;
        }

        .settings-button-action:hover {
            background: #0052a3;
        }

        .settings-button-action.secondary {
            background: #f8f9fa;
            color: #333; /* Darker text for better contrast on light background */
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .settings-button-action.secondary:hover {
            background: #f0f0f0;
            border-color: rgba(0, 0, 0, 0.15);
            color: #1d1d1d; /* Even darker on hover for better contrast */
        }

        /* Add Icon Modal */
        .add-icon-content {
            padding: 16px 0;
        }

        .add-icon-instructions {
            margin-bottom: 20px;
        }

        .drop-zone {
            border: 2px dashed #e5e5e5;
            border-radius: 12px;
            padding: 32px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #fafbfc;
            margin-bottom: 20px;
        }

        .drop-zone:hover {
            border-color: #3b82f6;
            background: #f0f8ff;
        }

        .drop-zone.drag-over {
            border-color: #3b82f6;
            background: #f0f8ff;
            transform: scale(1.02);
        }

        .drop-zone-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .drop-zone-icon {
            color: #666;
            opacity: 0.7;
        }

        .drop-zone-title {
            font-size: 16px;
            font-weight: 600;
            color: #1d1d1d;
        }

        .drop-zone-subtitle {
            font-size: 13px;
            color: #666;
        }

        .common-sizes {
            margin-top: 12px;
        }

        .sizes-title {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
            text-align: center;
        }

        .size-options {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
        }

        .size-option {
            font-size: 11px;
            color: #666;
            background: #f8f9fa;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #e5e5e5;
            user-select: none;
        }

        .add-icon-preview {
            background: #f8f9fa;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .preview-title {
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1d;
            margin-bottom: 12px;
        }

        .preview-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .preview-icon {
            width: 48px;
            height: 48px;
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .preview-icon svg {
            max-width: 40px;
            max-height: 40px;
        }

        .preview-info {
            flex: 1;
        }

        .preview-name {
            font-size: 14px;
            font-weight: 500;
            color: #1d1d1d;
            margin-bottom: 4px;
        }

        .preview-size {
            font-size: 12px;
            color: #666;
        }

        .add-icon-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding-top: 16px;
            border-top: 1px solid #f0f0f0;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }

        .toast {
            background: #ffffff;
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid #e5e5e5;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            max-width: 400px;
            min-width: 300px;
            pointer-events: auto;
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.success {
            border-left: 4px solid #10b981;
            background: linear-gradient(135deg, #ffffff 0%, #f0fff4 100%);
        }

        .toast.error {
            border-left: 4px solid #ef4444;
            background: linear-gradient(135deg, #ffffff 0%, #fef2f2 100%);
        }

        .toast.warning {
            border-left: 4px solid #f59e0b;
            background: linear-gradient(135deg, #ffffff 0%, #fffbeb 100%);
        }

        .toast-icon {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .toast-icon.success {
            color: #10b981;
        }

        .toast-icon.error {
            color: #ef4444;
        }

        .toast-icon.warning {
            color: #f59e0b;
        }

        .toast-content {
            flex: 1;
            min-width: 0;
        }

        .toast-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #1d1d1d;
            line-height: 1.3;
        }

        .toast-message {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .toast-close {
            width: 16px;
            height: 16px;
            background: none;
            border: none;
            cursor: pointer;
            color: #999;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            flex-shrink: 0;
            margin-top: 2px;
            transition: all 0.2s;
        }

        .toast-close:hover {
            background: rgba(0, 0, 0, 0.05);
            color: #666;
        }

        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .toast-progress-bar {
            height: 100%;
            background: currentColor;
            width: 100%;
            transform: translateX(-100%);
            transition: transform linear;
        }

        .toast-progress-bar.success {
            background: #10b981;
        }

        .toast-progress-bar.error {
            background: #ef4444;
        }

        .toast-progress-bar.warning {
            background: #f59e0b;
        }

        /* Plugin Footer */
        .plugin-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 32px;
            background: #ffffff;
            border-top: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            font-size: 11px;
            color: #666;
            font-weight: 500;
            z-index: 100;
        }

        .footer-left,
        .footer-right {
            font-size: 11px;
            color: #666;
            font-weight: 500;
            letter-spacing: 0.25px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Plugin Header -->
        <div class="plugin-header">
            <div class="plugin-title">
                <h1>Icon Management</h1>
                <p>Organise and manage your design system icons</p>
            </div>
            <div class="header-actions">
                <button class="scan-button primary" id="headerScanButton">Scan for Icons</button>
                <button class="settings-button" id="settingsButton" title="Settings">
                    <i data-lucide="settings" style="width: 16px; height: 16px;"></i>
                </button>
            </div>
        </div>

        <!-- Scan Results -->
        <div class="scan-results" id="scanResults">
            <div class="result-stats">
                <div class="stat">
                    <span class="stat-value" id="iconCount">0</span> icons found
                </div>
                <div class="stat">
                    <span class="stat-value" id="masterCount">0</span> master components
                </div>
                <div class="stat">
                    <span class="stat-value" id="unresolvedCount">0</span> unresolved icons
                </div>
            </div>
            <div class="scan-actions">
                <button class="action-button" id="consolidateButton" disabled>Auto-Create Icon Components</button>
            </div>
            
            <!-- Progress (moved here for better visual hierarchy) -->
            <div class="progress" id="progress">
                <div class="progress-bar" id="progressBar"></div>
            </div>

            <!-- Status (moved here for better visual hierarchy) -->
            <div class="status-bar" id="statusBar"></div>
        </div>

        <!-- Status Legend -->
        <div class="status-legend" id="statusLegend">
            <div class="legend-item">
                <div class="legend-color purple"></div>
                <span>Master Icons</span>
            </div>
            <div class="legend-item">
                <div class="legend-color green"></div>
                <span>Instance Icons</span>
            </div>
            <div class="legend-item">
                <div class="legend-color orange"></div>
                <span>Unresolved Icons</span>
            </div>
        </div>



        <!-- Search -->
        <div class="search-section">
            <div class="search-row">
                <input type="text" class="search-input" placeholder="Search by icon name, page, or type..." autofocus>
                <div class="view-toggle">
                    <button class="view-button active" data-view="grid">Grid</button>
                    <button class="view-button" data-view="list">List</button>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="content">
            <!-- Icon Area -->
            <div class="icon-area">
                <!-- Empty State -->
                <div class="empty-state" id="emptyState">
                    <h3>No icons found</h3>
                    <p>Click "Scan for Icons" to discover icons in your Figma file, or add icons manually.</p>
                </div>

                <!-- Grid View -->
                <div class="icon-grid" id="iconGrid" style="display: none;">
                    <!-- Icons will be populated here -->
                </div>

                <!-- List View -->
                <div class="icon-list" id="iconList">
                    <!-- List items will be populated here -->
                </div>
            </div>

            <!-- Details Panel -->
            <div class="details-panel" id="detailsPanel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <div class="icon-name" id="selectedIconName">Icon name</div>
                    <button class="close-button" id="closeDetails" style="background: none; border: none; font-size: 16px; cursor: pointer; color: #666; padding: 4px;">×</button>
                </div>
                
                <div class="icon-actions">
                    <button class="swap-button" id="swapIconButton">Swap icon</button>
                </div>

                <!-- Variant Selector for Component Sets -->
                <div class="variant-selector" id="variantSelector" style="display: none;">
                    <div class="variant-header">
                        <div class="variant-title">Variants</div>
                        <div class="variant-count" id="variantCount">0 variants</div>
                    </div>
                    <div class="variant-tabs" id="variantTabs">
                        <!-- Variant tabs will be populated here -->
                    </div>
                </div>

                <div class="icon-status" id="iconStatus">
                    This icon is unresolved. <a href="#" id="addToLibrary">Add to icon library</a>
                </div>

                <div class="icon-preview">
                    <div class="preview-box" id="iconPreview">
                        <!-- Icon preview -->
                    </div>
                    <div class="icon-size" id="iconSize">24 × 24</div>
                </div>

                <div class="icon-info">
                    <div class="info-item">
                        <div class="info-label">Source</div>
                        <div class="info-value" id="iconSource">Unknown</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Type</div>
                        <div class="info-value" id="iconType">Component</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Page</div>
                        <div class="info-value" id="iconPage">Icons</div>
                    </div>
                </div>
                        </div>
        </div>
    </div>

    <!-- Auto-Replace Confirmation Dialog -->
    <div class="dialog-overlay" id="autoReplaceDialog">
        <div class="dialog">
            <div class="dialog-header">
                <div class="dialog-title">Auto-Create Icon Components</div>
                <div class="dialog-subtitle">This will convert unresolved icons into organised master components and instances.</div>
            </div>
            <div class="dialog-content">
                <div class="scope-options">
                    <div class="scope-option selected" data-scope="current-page">
                        <div class="scope-radio"></div>
                        <div class="scope-info">
                            <div class="scope-title">Current page only</div>
                            <div class="scope-description">Convert icons only on "<span id="currentPageNameDialog">This page</span>"</div>
                        </div>
                    </div>
                    <div class="scope-option" data-scope="all-pages">
                        <div class="scope-radio"></div>
                        <div class="scope-info">
                            <div class="scope-title">All pages</div>
                            <div class="scope-description">Convert icons across the entire Figma file</div>
                        </div>
                    </div>
                </div>
                
                <div class="impact-summary">
                    <div class="impact-title">Impact Preview</div>
                    <div class="impact-stats">
                        <div class="impact-stat">
                            <span class="impact-value" id="replaceableIcons">0</span> icons will be converted
                        </div>
                        <div class="impact-stat">
                            <span class="impact-value" id="newComponents">0</span> new master components will be created
                        </div>
                    </div>
                </div>
            </div>
            <div class="dialog-actions">
                <button class="dialog-button secondary" id="cancelReplace">Cancel</button>
                <button class="dialog-button primary" id="confirmReplace">Create Components</button>
            </div>
        </div>
    </div>

    <!-- Success & Refresh Dialog -->
    <div class="dialog-overlay" id="successDialog">
        <div class="dialog success-dialog">
            <div class="dialog-header">
                <div class="dialog-title">Auto-Replace Complete!</div>
                <div class="dialog-subtitle" id="successMessage">Successfully replaced icons with master components.</div>
            </div>
            <div class="dialog-content">
                <div class="refresh-prompt">
                    <div class="refresh-prompt-title">See your updated results</div>
                    <div class="refresh-prompt-text">
                        Your icons have been replaced with instances from the Icon Library. 
                        Would you like to refresh the scan to see the updated icon status?
                    </div>
                    <div class="refresh-actions">
                        <button class="refresh-button" id="refreshAndScan">Yes, Refresh Scan</button>
                        <button class="refresh-button secondary" id="skipRefresh">Skip for now</button>
                    </div>
                </div>
            </div>
            <div class="dialog-actions">
                <button class="dialog-button secondary" id="closeSuccess">Close</button>
            </div>
        </div>
    </div>

    <!-- Consolidate Dups Dialog -->
    <div class="dialog-overlay" id="consolidateDupsDialog">
        <div class="dialog">
            <div class="dialog-header">
                <div class="dialog-title">Consolidate Library Duplicates</div>
                <div class="dialog-subtitle">Remove duplicate master components from the Icon Library page.</div>
            </div>
            <div class="dialog-content">
                <div class="impact-summary">
                    <div class="impact-title">What will happen</div>
                    <div class="impact-stats">
                        <div class="impact-stat">
                            <span class="impact-value" id="duplicateCount">0</span> duplicate components will be removed
                        </div>
                        <div class="impact-stat">
                            <span class="impact-value" id="keepCount">0</span> unique components will be kept
                        </div>
                    </div>
                </div>
                
                <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                    <div style="font-size: 13px; font-weight: 600; color: #856404; margin-bottom: 8px;">⚠️ Important</div>
                    <div style="font-size: 12px; color: #856404; line-height: 1.4;">
                        This will permanently remove duplicate master components from your Icon Library. 
                        Instances of removed components will be updated to reference the kept components.
                    </div>
                </div>
            </div>
            <div class="dialog-actions">
                <button class="dialog-button secondary" id="cancelConsolidateDups">Cancel</button>
                <button class="dialog-button primary" id="confirmConsolidateDups">Consolidate Duplicates</button>
            </div>
        </div>
    </div>

    <!-- Icon Swap Dialog -->
    <div class="dialog-overlay" id="iconSwapDialog">
        <div class="dialog swap-dialog">
            <div class="dialog-header">
                <div class="dialog-title">Smart Icon Swap</div>
                <div class="dialog-subtitle">Replace this icon across your entire design file while preserving layout and properties</div>
                <div class="dialog-hint" id="swapDirectionHint" style="display: none;">
                    <i data-lucide="lightbulb" style="width: 12px; height: 12px; margin-right: 4px; color: #3b82f6;"></i>
                    <span style="font-size: 11px; color: #0369a1;">Tip: Click the arrow (→) above to swap the direction of replacement</span>
                </div>
            </div>
            <div class="dialog-content">
                <!-- Preview Section -->
                <div class="swap-preview">
                    <div class="swap-section">
                        <div class="swap-section-title">Current Icon</div>
                        <div class="swap-icon-preview" id="currentSwapIcon">
                            <div class="swap-icon-image" id="currentSwapImage"></div>
                            <div class="swap-icon-name" id="currentSwapName">Current Icon</div>
                            <div class="swap-icon-details" id="currentSwapDetails">24×24 • Page Name</div>
                        </div>
                    </div>
                    
                    <div class="swap-arrow" id="swapDirection" title="Click to reverse swap direction">
                        <i data-lucide="arrow-right" style="width: 24px; height: 24px;"></i>
                    </div>
                    
                    <div class="swap-section">
                        <div class="swap-section-title">New Icon</div>
                        <div class="swap-icon-preview" id="newSwapIcon">
                            <div class="swap-icon-image" id="newSwapImage">
                                <div class="swap-placeholder">Select a replacement icon from the grid below</div>
                            </div>
                            <div class="swap-icon-name" id="newSwapName">Choose replacement...</div>
                            <div class="swap-icon-details" id="newSwapDetails">Select from available icons</div>
                        </div>
                    </div>
                </div>
                
                <!-- Icon Selection Section -->
                <div class="swap-content-section">
                    <div class="swap-section-header">
                        <div class="swap-section-title-main">Choose Replacement Icon</div>
                    </div>
                    <div class="swap-section-description">
                        Select any master component or icon-like element to use as the replacement. Non-components will be automatically converted to master components.
                    </div>
                    
                    <div class="swap-search">
                        <input type="text" class="swap-search-input" id="swapSearchInput" placeholder="Search by name (e.g., home, arrow, user)...">
                    </div>
                    
                    <div class="swap-icon-grid-container">
                        <div class="swap-grid-status">
                            <span id="swapIconCount">Loading icons...</span>
                            <div class="swap-grid-legend">
                                <div class="swap-legend-item">
                                    <div style="width: 12px; height: 12px; background: #10b981; border-radius: 50%;"></div>
                                    <span>Ready to use</span>
                                </div>
                                <div class="swap-legend-item">
                                    <div style="width: 12px; height: 12px; background: #f59e0b; border-radius: 50%;"></div>
                                    <span>Will be converted</span>
                                </div>
                            </div>
                        </div>
                        <div class="swap-icon-grid" id="swapIconGrid">
                            <!-- Available icons will be populated here -->
                        </div>
                    </div>
                </div>
                
                <!-- Size Adjustment Section -->
                <div class="swap-content-section">
                    <div class="swap-sizing" id="swapSizing" style="display: none;">
                        <div class="sizing-title">⚖️ Size Adjustment Options</div>
                        <div class="sizing-comparison">
                            <div class="size-info">
                                <span class="size-label">Current Size:</span>
                                <span class="size-value" id="currentIconSize">24×24</span>
                            </div>
                            <div class="size-info">
                                <span class="size-label">Replacement Size:</span>
                                <span class="size-value" id="replacementIconSize">32×32</span>
                            </div>
                        </div>
                        <div class="sizing-options">
                            <label class="sizing-option">
                                <input type="radio" name="sizingMode" value="scale-to-fit" checked>
                                <span class="sizing-option-text">
                                    <strong>Scale to fit current size</strong><br>
                                    Resize the replacement icon to match the current icon's dimensions. Preserves existing layouts.
                                </span>
                            </label>
                            <label class="sizing-option">
                                <input type="radio" name="sizingMode" value="keep-original">
                                <span class="sizing-option-text">
                                    <strong>Use replacement's original size</strong><br>
                                    Keep the new icon at its natural size. All instances will update to the new dimensions.
                                </span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Conversion Notice -->
                <div class="swap-content-section">
                    <div class="swap-conversion" id="swapConversion" style="display: none;">
                                            <div class="conversion-notice">
                        <div class="conversion-icon">
                            <i data-lucide="zap" style="width: 20px; height: 20px;"></i>
                        </div>
                            <div class="conversion-text">
                                <div class="conversion-title">Component Conversion Required</div>
                                <div class="conversion-description">
                                    This element will be converted to a master component with the name "<strong id="conversionComponentName"></strong>" and organised in your Icon Library.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Impact Preview -->
                <div class="swap-content-section">
                    <div class="swap-impact" id="swapImpact" style="display: none;">
                        <div class="impact-title">📊 Swap Impact</div>
                        <div class="impact-stats">
                            <div class="impact-stat">
                                <span class="impact-value" id="swapInstanceCount">0</span> instances will be updated
                            </div>
                            <div class="impact-stat">
                                <span class="impact-value" id="swapPageCount">0</span> pages will be affected
                            </div>
                        </div>
                        <div class="swap-notice">
                            <div style="font-size: 12px; color: #666; margin-top: 8px; line-height: 1.4;">
                                <strong>What happens:</strong> The original icon will be safely archived to "🗄️ Archived Icons" page, 
                                and all instances across your file will be updated to use the new icon while preserving position, 
                                rotation, opacity, effects, and other properties.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dialog-actions">
                <button class="dialog-button secondary" id="cancelIconSwap">Cancel</button>
                <button class="dialog-button primary" id="confirmIconSwap" disabled>
                    <span id="swapButtonText">Select an icon to continue</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Onboarding Overlay -->
    <div class="onboarding-overlay" id="onboardingOverlay">
        <div class="onboarding-step" id="onboardingStep">
            <div class="onboarding-progress" id="onboardingProgress">1 of 4</div>
            <button class="onboarding-close" id="onboardingClose">×</button>
            <div class="onboarding-visual" id="onboardingVisual">
                <i data-lucide="target" style="width: 48px; height: 48px;"></i>
            </div>
            <h2 id="onboardingTitle">Welcome to Icon Management!</h2>
            <p id="onboardingDescription">This plugin helps you organise, replace, and manage icons across your entire Figma design system.</p>
            <div class="onboarding-actions">
                <button class="onboarding-button secondary" id="onboardingSkip">Skip tutorial</button>
                <button class="onboarding-button primary" id="onboardingNext">Get started</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">
                <h2 class="settings-title">Settings</h2>
                <button class="onboarding-close" id="settingsClose">×</button>
            </div>
            
            <div class="settings-option">
                <div class="settings-option-info">
                    <div class="settings-option-title">Bulk Export Icons</div>
                    <div class="settings-option-description">Export all master icons from your Icon Library as SVG files for handover to developers</div>
                </div>
                <button class="settings-button-action" id="bulkExportIcons">Export All Icons</button>
            </div>
            
            <div class="settings-option">
                <div class="settings-option-info">
                    <div class="settings-option-title">Tutorial</div>
                    <div class="settings-option-description">Watch the onboarding tutorial again to learn about plugin features</div>
                </div>
                <button class="settings-button-action" id="replayTutorial">Replay tutorial</button>
            </div>
            
            <div class="settings-option">
                <div class="settings-option-info">
                    <div class="settings-option-title">About</div>
                    <div class="settings-option-description">Icon Management Plugin v1.0 - Organise your design system icons</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Icon Modal -->
    <div class="settings-modal" id="addIconModal">
        <div class="settings-content">
            <div class="settings-header">
                <h2 class="settings-title">Add Icon to Library</h2>
                <button class="onboarding-close" id="addIconClose">×</button>
            </div>
            
            <div class="add-icon-content">
                <div class="add-icon-instructions">
                    <div class="settings-option-title">Drop SVG File</div>
                    <div class="settings-option-description">Upload an SVG file to add to your Icon Library. The icon will maintain its original size and be automatically organized.</div>
                </div>
                
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-content">
                        <div class="drop-zone-icon">
                            <i data-lucide="upload" style="width: 32px; height: 32px;"></i>
                        </div>
                        <div class="drop-zone-text">
                            <div class="drop-zone-title">Drop SVG file here</div>
                            <div class="drop-zone-subtitle">or click to browse</div>
                        </div>
                        <div class="common-sizes" id="commonSizes">
                            <div class="sizes-title">Common icon sizes</div>
                            <div class="size-options">
                                <span class="size-option" data-size="12">12×12</span>
                                <span class="size-option" data-size="16">16×16</span>
                                <span class="size-option" data-size="20">20×20</span>
                                <span class="size-option" data-size="24">24×24</span>
                                <span class="size-option" data-size="28">28×28</span>
                                <span class="size-option" data-size="32">32×32</span>
                                <span class="size-option" data-size="40">40×40</span>
                                <span class="size-option" data-size="48">48×48</span>
                                <span class="size-option" data-size="56">56×56</span>
                                <span class="size-option" data-size="64">64×64</span>
                            </div>
                        </div>
                    </div>
                    <input type="file" id="fileInput" accept=".svg,image/svg+xml,text/xml,application/xml" style="display: none;">
                </div>
                
                <div class="add-icon-preview" id="addIconPreview" style="display: none;">
                    <div class="preview-title">Preview</div>
                    <div class="preview-container">
                        <div class="preview-icon" id="previewIcon"></div>
                        <div class="preview-info">
                            <div class="preview-name" id="previewName">icon.svg</div>
                            <div class="preview-size" id="previewSize">24×24</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="add-icon-actions">
                <button class="settings-button-action secondary" id="cancelAddIcon">Cancel</button>
                <button class="settings-button-action" id="confirmAddIcon" disabled>Add to Library</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" id="contextMenuConvert">
            <i data-lucide="component" style="width: 14px; height: 14px; margin-right: 8px; vertical-align: text-bottom;"></i>
            Convert to Component
        </div>
        <div class="context-menu-item" id="contextMenuReplace">
            <i data-lucide="replace" style="width: 14px; height: 14px; margin-right: 8px; vertical-align: text-bottom;"></i>
            Replace with Instance
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="contextMenuSwap">
            <i data-lucide="refresh-cw" style="width: 14px; height: 14px; margin-right: 8px; vertical-align: text-bottom;"></i>
            Swap Icon
        </div>
        <div class="context-menu-item" id="contextMenuSelect">
            <i data-lucide="mouse-pointer" style="width: 14px; height: 14px; margin-right: 8px; vertical-align: text-bottom;"></i>
            Select in Canvas
        </div>
    </div>

    <!-- Footer -->
    <div class="plugin-footer">
        <div class="footer-left">Icon Management v1.0</div>
        <div class="footer-right">Artificial Lack of Intelligence © 2025</div>
    </div>

<script>
        // State
        let iconData = {
            totalIcons: 0,
            inconsistencies: 0,
            discoveredIcons: [],
            scanComplete: false
        };

        // Onboarding System
        let currentOnboardingStep = 0;
        const onboardingSteps = [
            {
                title: "Welcome to Icon Management!",
                description: "This plugin helps you organise, replace, and manage icons across your entire Figma design system.",
                visual: "target",
                action: "Get started"
            },
            {
                title: "Discover Icons in Your File",
                description: "Click 'Scan for Icons' to find all icons in your Figma file. The plugin will identify components, instances, and unresolved icon elements.",
                visual: "search",
                action: "Next"
            },
            {
                title: "Auto-Replace Unresolved Icons",
                description: "Use 'Auto-Create Icon Components' to convert similar icons into organised master components. This cleans up your design system automatically.",
                visual: "zap",
                action: "Next"
            },
            {
                title: "Smart Icon Swapping",
                description: "Select any icon and use 'Swap icon' to replace it across your entire file while preserving all positioning and properties.",
                visual: "refresh-cw",
                action: "Start using"
            }
        ];

        // Onboarding state
        let onboardingCompleted = false;

        // Check if user has seen onboarding
        function hasSeenOnboarding() {
            return onboardingCompleted;
        }

        // Mark onboarding as complete
        function markOnboardingComplete() {
            onboardingCompleted = true;
            // Store in Figma's persistent storage via backend
            parent.postMessage({ 
                pluginMessage: { 
                    type: 'set-onboarding-complete',
                    completed: true
                } 
            }, '*');
        }

        // Show onboarding
        function showOnboarding() {
            currentOnboardingStep = 0;
            updateOnboardingStep();
            document.getElementById('onboardingOverlay').classList.add('show');
        }

        // Hide onboarding
        function hideOnboarding() {
            document.getElementById('onboardingOverlay').classList.remove('show');
        }

        // Update onboarding step
        function updateOnboardingStep() {
            const step = onboardingSteps[currentOnboardingStep];
            const totalSteps = onboardingSteps.length;
            
            document.getElementById('onboardingProgress').textContent = `${currentOnboardingStep + 1} of ${totalSteps}`;
            document.getElementById('onboardingTitle').textContent = step.title;
            document.getElementById('onboardingDescription').textContent = step.description;
            document.getElementById('onboardingVisual').innerHTML = `<i data-lucide="${step.visual}" style="width: 48px; height: 48px;"></i>`;
            document.getElementById('onboardingNext').textContent = step.action;
            
            // Re-initialize Lucide icons for the new icon
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // Next onboarding step
        function nextOnboardingStep() {
            if (currentOnboardingStep < onboardingSteps.length - 1) {
                currentOnboardingStep++;
                updateOnboardingStep();
            } else {
                // Complete onboarding
                markOnboardingComplete();
                hideOnboarding();
            }
        }

        // Skip onboarding
        function skipOnboarding() {
            markOnboardingComplete();
            hideOnboarding();
        }

        // Settings modal functions
        function showSettingsModal() {
            document.getElementById('settingsModal').classList.add('show');
        }

        function hideSettingsModal() {
            document.getElementById('settingsModal').classList.remove('show');
        }

        let currentView = 'grid';
        let selectedIcon = null;
        let isSelectingFromCanvas = false; // Prevent selection loops
        let currentPageName = '';
        let searchFilter = '';
        let newStatusCleanupTimer = null;
        let currentMode = 'management'; // 'library' or 'management'

        // DOM Elements
        const elements = {
            searchInput: document.querySelector('.search-input'),
            addButton: document.querySelector('.add-button'),
            viewButtons: document.querySelectorAll('.view-button'),
            progress: document.getElementById('progress'),
            progressBar: document.getElementById('progressBar'),
            statusBar: document.getElementById('statusBar'),
            scanResults: document.getElementById('scanResults'),
            statusLegend: document.getElementById('statusLegend'),
            iconCount: document.getElementById('iconCount'),
            unresolvedCount: document.getElementById('unresolvedCount'),
            scanButton: document.getElementById('headerScanButton'), // Using headerScanButton as the main scan button
            consolidateButton: document.getElementById('consolidateButton'),
            emptyState: document.getElementById('emptyState'),
            iconGrid: document.getElementById('iconGrid'),
            iconList: document.getElementById('iconList'),
            detailsPanel: document.getElementById('detailsPanel'),
            selectedIconName: document.getElementById('selectedIconName'),
            iconPreview: document.getElementById('iconPreview'),
            iconSize: document.getElementById('iconSize'),
            iconSource: document.getElementById('iconSource'),
            iconType: document.getElementById('iconType'),
            iconPage: document.getElementById('iconPage'),
            iconStatus: document.getElementById('iconStatus'),
            addToLibrary: document.getElementById('addToLibrary')
        };

        // Toast System
        let toastCounter = 0;

        function showToast(title, message, type = 'success', duration = 5000) {
            const toastContainer = document.getElementById('toastContainer');
            if (!toastContainer) return;

            toastCounter++;
            const toastId = `toast-${toastCounter}`;

            // Choose appropriate icon
            let iconName = 'check-circle';
            if (type === 'error') iconName = 'x-circle';
            if (type === 'warning') iconName = 'alert-triangle';

            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.id = toastId;
            toast.innerHTML = `
                <div class="toast-icon ${type}">
                    <i data-lucide="${iconName}" style="width: 20px; height: 20px;"></i>
                </div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    ${message ? `<div class="toast-message">${message}</div>` : ''}
                </div>
                <button class="toast-close" onclick="hideToast('${toastId}')">
                    <i data-lucide="x" style="width: 12px; height: 12px;"></i>
                </button>
                <div class="toast-progress">
                    <div class="toast-progress-bar ${type}"></div>
                </div>
            `;

            // Add to container
            toastContainer.appendChild(toast);

            // Initialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }

            // Show toast with animation
            setTimeout(() => {
                toast.classList.add('show');
                
                // Start progress bar animation
                const progressBar = toast.querySelector('.toast-progress-bar');
                if (progressBar && duration > 0) {
                    progressBar.style.transitionDuration = `${duration}ms`;
                    progressBar.style.transform = 'translateX(0%)';
                }
            }, 10);

            // Auto-hide after duration
            if (duration > 0) {
                setTimeout(() => {
                    hideToast(toastId);
                }, duration);
            }

            return toastId;
        }

        function hideToast(toastId) {
            const toast = document.getElementById(toastId);
            if (!toast) return;

            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }

        // Make hideToast globally accessible for onclick handlers
        window.hideToast = hideToast;

        // Context Menu System
        let contextMenuTarget = null;
        let contextMenuIcon = null;

        function showContextMenu(event, iconIndex) {
            event.preventDefault();
            event.stopPropagation();
            
            const contextMenu = document.getElementById('contextMenu');
            if (!contextMenu || !iconData.discoveredIcons || !iconData.discoveredIcons[iconIndex]) {
                return;
            }
            
            const icon = iconData.discoveredIcons[iconIndex];
            contextMenuTarget = event.target.closest('.icon-slot');
            contextMenuIcon = icon;
            
            // Customize menu based on icon type
            customizeContextMenu(icon);
            
            // Position the menu
            const x = event.clientX;
            const y = event.clientY;
            
            // Get plugin container bounds (not viewport)
            const pluginContainer = document.body;
            const containerRect = pluginContainer.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;
            
            // Show the menu temporarily to get its dimensions
            contextMenu.style.position = 'fixed';
            contextMenu.style.visibility = 'hidden';
            contextMenu.style.display = 'block';
            const menuRect = contextMenu.getBoundingClientRect();
            contextMenu.style.visibility = 'visible';
            
            let menuX = x;
            let menuY = y;
            
            // Smart positioning with padding from edges
            const padding = 8;
            
            // Check horizontal bounds - keep menu within plugin window
            if (x + menuRect.width > containerWidth - padding) {
                // Try to position to the left of the cursor
                menuX = Math.max(padding, x - menuRect.width);
            }
            
            // Check vertical bounds - keep menu within plugin window
            if (y + menuRect.height > containerHeight - padding) {
                // Try to position above the cursor
                menuY = Math.max(padding, y - menuRect.height);
            }
            
            // Final bounds check - ensure menu doesn't go off edges
            menuX = Math.max(padding, Math.min(menuX, containerWidth - menuRect.width - padding));
            menuY = Math.max(padding, Math.min(menuY, containerHeight - menuRect.height - padding));
            
            contextMenu.style.left = `${menuX}px`;
            contextMenu.style.top = `${menuY}px`;
            contextMenu.style.display = 'block';
            
            // Re-initialize icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function hideContextMenu() {
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            contextMenuTarget = null;
            contextMenuIcon = null;
        }

        function customizeContextMenu(icon) {
            const convertItem = document.getElementById('contextMenuConvert');
            const replaceItem = document.getElementById('contextMenuReplace');
            const swapItem = document.getElementById('contextMenuSwap');
            const selectItem = document.getElementById('contextMenuSelect');
            
            // Reset all items
            [convertItem, replaceItem, swapItem, selectItem].forEach(item => {
                if (item) {
                    item.classList.remove('disabled');
                    item.style.display = 'block';
                }
            });
            
            // Customize based on icon status
            switch (icon.status) {
                case 'unresolved':
                    // For unresolved icons: show convert and replace options
                    if (convertItem) convertItem.style.display = 'block';
                    if (replaceItem) replaceItem.style.display = 'block';
                    break;
                    
                case 'master':
                    // For master icons: hide convert, show swap
                    if (convertItem) convertItem.style.display = 'none';
                    if (replaceItem) replaceItem.style.display = 'none';
                    break;
                    
                case 'instance':
                    // For instances: hide convert and replace, show swap
                    if (convertItem) convertItem.style.display = 'none';
                    if (replaceItem) replaceItem.style.display = 'none';
                    break;
                    
                default:
                    // Default: show all options
                    break;
            }
            
            // Always show swap and select
            if (swapItem) swapItem.style.display = 'block';
            if (selectItem) selectItem.style.display = 'block';
        }

        // Helper function to detect if an icon needs a background (for white/light icons)
        function createIconWithBackground(iconPreview, altText, additionalClasses = '') {
            const hasBackground = iconPreview.toLowerCase().includes('fill') && 
                                (iconPreview.toLowerCase().includes('#fff') || 
                                 iconPreview.toLowerCase().includes('white') ||
                                 iconPreview.toLowerCase().includes('#f') ||
                                 iconPreview.toLowerCase().includes('rgb(255') ||
                                 iconPreview.toLowerCase().includes('currentcolor'));
            
            const backgroundStyle = hasBackground ? 'background: #f0f0f0; padding: 4px; border-radius: 4px;' : '';
            
            return `<img src="${iconPreview}" alt="${altText}" class="${additionalClasses}" 
                     style="max-width: 100%; max-height: 100%; object-fit: contain; ${backgroundStyle}">`;
        }

        // Enhanced version that analyzes actual SVG content for better detection
        function needsBackground(svgContent) {
            if (!svgContent) return false;
            
            const svg = svgContent.toLowerCase();
            
            // Check for white or very light fills
            const whitePatterns = [
                '#fff', '#ffffff', 'white', 'rgb(255,255,255)', 'rgb(255, 255, 255)',
                '#f0f0f0', '#fafafa', '#fcfcfc', '#fdfdfd', '#fefefe',
                'currentcolor' // Often resolves to light colors in Figma
            ];
            
            // Check for transparency or no fill
            const transparentPatterns = [
                'fill="none"', 'fill:none', 'opacity="0"', 'fill-opacity="0"'
            ];
            
            const hasWhiteFill = whitePatterns.some(pattern => svg.includes(pattern));
            const isTransparent = transparentPatterns.some(pattern => svg.includes(pattern));
            
            return hasWhiteFill || isTransparent;
        }

        // Context Menu Action Handlers
        function handleContextMenuConvert() {
            if (!contextMenuIcon) return;
            
            // Validate that the icon is still valid for conversion
            if (contextMenuIcon.status === 'master' || contextMenuIcon.status === 'instance') {
                showToast(
                    'Icon Already Converted',
                    'This icon is already a master component or instance and doesn\'t need to be converted.',
                    'info',
                    5000
                );
                hideContextMenu();
                return;
            }
            
            hideContextMenu();
            
            // Show loading state
            showToast('Converting Icon...', `Converting "${contextMenuIcon.name}" to component`, 'info', 3000);
            
            // Convert single icon to component
            parent.postMessage({
                pluginMessage: {
                    type: 'convert-single-icon',
                    iconId: contextMenuIcon.id,
                    iconName: contextMenuIcon.name
                }
            }, '*');
        }

        function handleContextMenuReplace() {
            if (!contextMenuIcon) return;
            
            hideContextMenu();
            
            // Show replace dialog to select master component
            showReplaceWithInstanceDialog(contextMenuIcon);
        }

        function handleContextMenuSwap() {
            if (!contextMenuIcon) return;
            
            hideContextMenu();
            
            // Open swap dialog
            showIconSwapDialog(contextMenuIcon);
        }

        function handleContextMenuSelect() {
            if (!contextMenuIcon) return;
            
            hideContextMenu();
            
            // Select icon on canvas
            parent.postMessage({ 
                pluginMessage: { 
                    type: 'select-icon',
                    iconId: contextMenuIcon.id 
                } 
            }, '*');
            
            showToast('Icon Selected', `Selected "${contextMenuIcon.name}" on canvas`, 'success', 3000);
        }

        function showReplaceWithInstanceDialog(icon) {
            // Get all master components that could be replacements
            const masterComponents = iconData.discoveredIcons.filter(masterIcon => 
                masterIcon.status === 'master' && masterIcon.id !== icon.id
            );
            
            if (masterComponents.length === 0) {
                showToast('No Master Components', 'Create some master components first using Auto-Create Icon Components.', 'warning', 5000);
                return;
            }
            
            // Smart replacement logic
            let selectedMaster = null;
            
            // 1. Try to find exact name match (case-insensitive)
            selectedMaster = masterComponents.find(comp => 
                comp.name.toLowerCase() === icon.name.toLowerCase()
            );
            
            // 2. If no exact match, try to find similar name (contains or starts with)
            if (!selectedMaster) {
                const iconNameLower = icon.name.toLowerCase();
                selectedMaster = masterComponents.find(comp => {
                    const compNameLower = comp.name.toLowerCase();
                    return compNameLower.includes(iconNameLower) || iconNameLower.includes(compNameLower);
                });
            }
            
            // 3. If still no match and only one master component, use it
            if (!selectedMaster && masterComponents.length === 1) {
                selectedMaster = masterComponents[0];
            }
            
            // 4. If we found a good match, replace automatically
            if (selectedMaster) {
                // Send replace request to backend
                parent.postMessage({
                    pluginMessage: {
                        type: 'replace-with-instance',
                        unresolvedIcon: icon,
                        masterComponent: selectedMaster
                    }
                }, '*');
                
                showToast('Replacing Icon...', `Replacing "${icon.name}" with instance of "${selectedMaster.name}"`, 'info', 3000);
                return;
            }
            
            // 5. If no good match found, show selection dialog
            const componentNames = masterComponents.map(comp => comp.name);
            const selectedName = prompt(`Replace "${icon.name}" with instance of:\n\n${componentNames.slice(0, 10).join('\n')}\n\nEnter the exact name:`);
            
            if (selectedName) {
                const masterComponent = masterComponents.find(comp => comp.name === selectedName);
                if (masterComponent) {
                    // Send replace request to backend
                    parent.postMessage({
                        pluginMessage: {
                            type: 'replace-with-instance',
                            unresolvedIcon: icon,
                            masterComponent: masterComponent
                        }
                    }, '*');
                    
                    showToast('Replacing Icon...', `Replacing "${icon.name}" with instance of "${masterComponent.name}"`, 'info', 3000);
                } else {
                    showToast('Component Not Found', `No master component named "${selectedName}" found.`, 'error', 5000);
                }
            }
        }

        async function downloadExportedIcons(exportData) {
            try {
                console.log('Starting download of exported icons:', exportData);
                
                // Create a new JSZip instance
                const zip = new JSZip();
                
                // Create a summary file with project information
                const summaryContent = `# ${exportData.projectName} - Icon Export
                
Export Date: ${new Date(exportData.exportDate).toLocaleString()}
Total Icons: ${exportData.totalIcons}
Total Variants: ${exportData.totalVariants}

## Icons Included:
${exportData.icons.map(icon => {
    const pageInfo = icon.page ? ` (from "${icon.page}")` : '';
    if (icon.variants && icon.variants.length > 0) {
        return `- ${icon.name} (Component Set with ${icon.variants.length} variants)${pageInfo}\n${icon.variants.map(v => `  - ${v.name}`).join('\n')}`;
    } else {
        return `- ${icon.name}${pageInfo}`;
    }
}).join('\n')}

Generated by Icon Management Plugin for Figma
${exportData.branding || 'Artificial Lack of Intelligence © 2025'}
`;
                
                // Add summary file to zip
                zip.file(`${sanitizeFileName(exportData.projectName)}-icons-summary.md`, summaryContent);
                
                // Add each icon to the zip
                exportData.icons.forEach(icon => {
                    if (icon.variants && icon.variants.length > 0) {
                        // Component set with variants - create a folder for the component set
                        const folderName = sanitizeFileName(icon.name);
                        const folder = zip.folder(folderName);
                        
                        icon.variants.forEach(variant => {
                            const fileName = sanitizeFileName(`${variant.name}.svg`);
                            folder.file(fileName, variant.svg);
                        });
                    } else if (icon.svg) {
                        // Regular component - add directly to root
                        const fileName = sanitizeFileName(`${icon.name}.svg`);
                        zip.file(fileName, icon.svg);
                    }
                });
                
                // Generate the zip file and download it
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const zipFileName = `${sanitizeFileName(exportData.projectName)}-icons-export.zip`;
                
                // Create download link for the zip file
                const url = URL.createObjectURL(zipBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = zipFileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the object URL
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                
                console.log(`Downloaded zip file: ${zipFileName}`);
                
                // Show success message
                setTimeout(() => {
                    showToast(
                        'Download Complete 📦',
                        `All icons packaged in ${zipFileName}. Component sets are organized in folders with individual variant files.`,
                        'success',
                        8000
                    );
                }, 1000);
                
            } catch (error) {
                console.error('Error creating zip file:', error);
                showToast(
                    'Download Error',
                    'Failed to create zip file. Check the browser console for details.',
                    'error',
                    5000
                );
            }
        }

        function sanitizeFileName(fileName) {
            // Remove or replace invalid characters for file names
            return fileName
                .replace(/[^a-zA-Z0-9\-_\.]/g, '-') // Replace invalid chars with dash
                .replace(/--+/g, '-') // Replace multiple dashes with single dash
                .replace(/^-|-$/g, '') // Remove leading/trailing dashes
                .toLowerCase();
        }



        function getHumanErrorMessage(error) {
            const errorStr = error.toLowerCase();
            
            // Network/connection errors
            if (errorStr.includes('network') || errorStr.includes('connection') || errorStr.includes('timeout')) {
                return 'Unable to connect to Figma. Please check your internet connection and try again.';
            }
            
            // Permission errors
            if (errorStr.includes('permission') || errorStr.includes('access') || errorStr.includes('unauthorized')) {
                return 'Permission denied. You may not have edit access to this file or some elements are locked.';
            }
            
            // Enhanced node not found errors
            if (errorStr.includes('not found') && errorStr.includes('deleted or moved')) {
                return 'The selected icon could not be found. It may have been deleted or moved to another page. Try refreshing the plugin to get the latest icon data.';
            }
            
            // Node not found errors (general)
            if (errorStr.includes('not found') || errorStr.includes('does not exist') || errorStr.includes('invalid node')) {
                return 'The selected icon could not be found. It may have been deleted or moved to another page.';
            }
            
            // Node accessibility errors
            if (errorStr.includes('no longer accessible') || errorStr.includes('corrupted')) {
                return 'The selected icon is no longer accessible. It may have been corrupted or deleted. Try refreshing the plugin and selecting a different icon.';
            }
            
            // Dimension errors
            if (errorStr.includes('no dimensions') || errorStr.includes('invisible')) {
                return 'The selected icon has no dimensions and cannot be converted. It may be invisible or corrupted.';
            }
            
            // Already converted errors
            if (errorStr.includes('already a master component') || errorStr.includes('already a component set')) {
                return 'This icon is already a master component and doesn\'t need to be converted.';
            }
            
            // Clone errors
            if (errorStr.includes('failed to clone')) {
                return 'Unable to create a copy of the icon. The icon may be locked or corrupted.';
            }
            
            // Component errors
            if (errorStr.includes('component') && errorStr.includes('invalid')) {
                return 'The selected component is invalid or has been corrupted. Try selecting a different icon.';
            }
            
            // Instance errors
            if (errorStr.includes('instance') && errorStr.includes('main component')) {
                return 'This icon instance is disconnected from its master component. The master may have been deleted.';
            }
            
            // Memory/size errors
            if (errorStr.includes('memory') || errorStr.includes('too large') || errorStr.includes('exceeded')) {
                return 'This operation is too large for the available memory. Try working with fewer icons at once.';
            }
            
            // File errors
            if (errorStr.includes('file') && (errorStr.includes('corrupted') || errorStr.includes('invalid'))) {
                return 'The Figma file appears to be corrupted or invalid. Try refreshing the page and reopening the file.';
            }
            
            // Selection errors
            if (errorStr.includes('selection') || errorStr.includes('nothing selected')) {
                return 'Please select an icon first before performing this action.';
            }
            
            // Generic swap errors
            if (errorStr.includes('swap') || errorStr.includes('replace')) {
                return 'Unable to complete the icon swap. The icons may be locked or you may not have edit permissions.';
            }
            
            // Archive errors
            if (errorStr.includes('archive')) {
                return 'Unable to archive the original icon. You may not have permission to create new pages.';
            }
            
            // Conversion errors
            if (errorStr.includes('convert') || errorStr.includes('create component')) {
                return 'Unable to convert this element to a component. It may contain unsupported content or be locked.';
            }
            
            // Generic plugin errors
            if (errorStr.includes('plugin')) {
                return 'A plugin error occurred. Try closing and reopening the plugin, or refresh the page.';
            }
            
            // API errors
            if (errorStr.includes('api') || errorStr.includes('figma api')) {
                return 'Figma API is currently unavailable. Please try again in a few moments.';
            }

            // Library page errors
            if (errorStr.includes('library') && errorStr.includes('not found')) {
                return 'Icon Library page not found. The plugin will create one automatically on the next operation.';
            }

            // Locked element errors
            if (errorStr.includes('locked') || errorStr.includes('read-only')) {
                return 'Some elements are locked and cannot be modified. Unlock them in Figma and try again.';
            }
            
            // Default fallback - clean up the technical message
            let cleanError = error.replace(/Error:|TypeError:|ReferenceError:|SyntaxError:/gi, '').trim();
            cleanError = cleanError.charAt(0).toUpperCase() + cleanError.slice(1);
            
            // If still too technical, provide generic message
            if (cleanError.length > 100 || cleanError.includes('undefined') || cleanError.includes('null')) {
                return 'Something went wrong. Please try again or contact support if the problem persists.';
            }
            
            return cleanError;
        }

        // Functions
        function showStatus(message, type = 'info') {
            elements.statusBar.textContent = message;
            elements.statusBar.className = `status-bar show ${type}`;
            
            // Keep different message types visible for appropriate durations
            let timeout;
            switch (type) {
                case 'error':
                    timeout = 10000; // 10 seconds for errors
                    break;
                case 'warning':
                    timeout = 8000; // 8 seconds for warnings
                    break;
                case 'success':
                    timeout = 6000; // 6 seconds for success messages (longer than default)
                    break;
                default:
                    timeout = 4000; // 4 seconds for info messages
            }
            
            setTimeout(() => {
                elements.statusBar.classList.remove('show');
            }, timeout);
        }

        function showProgress(show = true) {
            elements.progress.classList.toggle('show', show);
        }

        function updateProgress(percentage) {
            elements.progressBar.style.width = `${percentage}%`;
        }

        function updateStats() {
            // Only count valid, non-deleted, non-archived icons
            const validIcons = iconData.discoveredIcons ? iconData.discoveredIcons.filter(icon => 
                icon && 
                icon.id && 
                icon.page !== '🗄️ Archived Icons' && 
                !icon.name.toLowerCase().startsWith('archive/') && 
                !icon.name.toLowerCase().includes('[archived]')
            ) : [];
            const actualCount = validIcons.length;
            const masterCount = validIcons.filter(icon => icon.status === 'master' || icon.status === 'master-component').length;
            const unresolvedCount = validIcons.filter(icon => icon.status === 'unresolved' || icon.status === 'in-frame').length;
            
            elements.iconCount.textContent = actualCount;
            elements.unresolvedCount.textContent = unresolvedCount;
            
            // Update master count in scan results
            const masterCountElement = document.getElementById('masterCount');
            if (masterCountElement) {
                masterCountElement.textContent = masterCount;
            }
        }

        function isOnIconLibraryPage() {
            return currentPageName === '🎯 Icon Library';
        }
        
        function updateMode() {
            // Don't update mode if we don't know the current page yet
            if (!currentPageName) {
                return;
            }
            
            const wasLibraryMode = currentMode === 'library';
            currentMode = isOnIconLibraryPage() ? 'library' : 'management';
            
            // Update UI based on mode
            updateModeUI();
            
            // Re-populate if mode changed
            if ((wasLibraryMode && currentMode === 'management') || (!wasLibraryMode && currentMode === 'library')) {
                populateIcons();
            }
        }
        
        function updateModeUI() {
            const scanResults = document.getElementById('scanResults');
            
            if (currentMode === 'library') {
                // Icon Library Mode
                
                // Hide auto-replace action
                elements.consolidateButton.style.display = 'none';
                
                // Show different stats in library mode
                updateLibraryModeStats();
                
            } else {
                // Icon Management Mode  
                
                // Show auto-replace action
                elements.consolidateButton.style.display = 'inline-block';
                
                // Show normal stats
                updateStats();
            }
        }
        
        function updateLibraryModeStats() {
            if (!iconData.discoveredIcons) return;
            
            // Filter to library page only, excluding archived icons
            const libraryIcons = iconData.discoveredIcons.filter(icon => 
                icon && 
                icon.id && 
                icon.page === currentPageName &&
                icon.page !== '🗄️ Archived Icons' && 
                !icon.name.toLowerCase().startsWith('archive/') && 
                !icon.name.toLowerCase().includes('[archived]')
            );
            
            const masterCount = libraryIcons.filter(icon => 
                icon.status === 'master' || icon.status === 'master-component'
            ).length;
            
            const duplicateCount = libraryIcons.filter(icon => icon.isDuplicate).length;
            
            elements.iconCount.textContent = libraryIcons.length;
            document.getElementById('masterCount').textContent = masterCount;
            elements.unresolvedCount.textContent = duplicateCount;
            
            // Update label for library mode
            const unresolvedLabel = elements.unresolvedCount.parentNode;
            if (unresolvedLabel && unresolvedLabel.textContent.includes('unresolved')) {
                unresolvedLabel.innerHTML = unresolvedLabel.innerHTML.replace('unresolved icons', 'duplicate components');
            }
        }

        // New status management with 2-minute auto-expiry
        function markIconAsNew(icon) {
            icon.isNew = true;
            icon.newTimestamp = Date.now();
        }

        function cleanupExpiredNewStatuses() {
            if (!iconData.discoveredIcons) return;
            
            const now = Date.now();
            const twoMinutes = 2 * 60 * 1000; // 2 minutes in milliseconds
            let hasChanges = false;
            
            iconData.discoveredIcons.forEach(icon => {
                if (icon.isNew && icon.newTimestamp && (now - icon.newTimestamp) > twoMinutes) {
                    icon.isNew = false;
                    delete icon.newTimestamp;
                    hasChanges = true;
                }
            });
            
            // Refresh UI if any changes were made
            if (hasChanges) {
                populateIcons();
            }
        }

        function startNewStatusCleanupTimer() {
            // Clear existing timer
            if (newStatusCleanupTimer) {
                clearInterval(newStatusCleanupTimer);
            }
            
            // Start new timer to check every 30 seconds
            newStatusCleanupTimer = setInterval(cleanupExpiredNewStatuses, 30000);
        }

        function stopNewStatusCleanupTimer() {
            if (newStatusCleanupTimer) {
                clearInterval(newStatusCleanupTimer);
                newStatusCleanupTimer = null;
            }
        }

        function switchView(view) {
            currentView = view;
            
            // Update buttons
            elements.viewButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            // Update display
            if (view === 'grid') {
                elements.iconGrid.style.display = 'block';
                elements.iconList.classList.remove('show');
            } else {
                elements.iconGrid.style.display = 'none';
                elements.iconList.classList.add('show');
            }
        }

        function getFilteredIcons() {
            if (!iconData.discoveredIcons) return [];
            
            return iconData.discoveredIcons.filter((icon, index) => {
                // First filter out invalid/deleted icons
                if (!icon || !icon.id) {
                    return false;
                }
                
                // Always exclude archived icons from all results
                if (icon.page === '🗄️ Archived Icons' || 
                    icon.name.toLowerCase().startsWith('archive/') || 
                    icon.name.toLowerCase().includes('[archived]')) {
                    return false;
                }
                
                // Mode-based filtering
                if (currentMode === 'library') {
                    // Library mode: only show icons from Icon Library page
                    if (icon.page !== currentPageName) {
                        return false;
                    }
                }
                
                // Search filter - more forgiving search
                if (searchFilter) {
                    const searchLower = searchFilter.toLowerCase();
                    const iconNameLower = icon.name.toLowerCase();
                    const iconPageLower = icon.page.toLowerCase();
                    
                    // Search in name, page, and source
                    if (!iconNameLower.includes(searchLower) && 
                        !iconPageLower.includes(searchLower) &&
                        !(icon.source && icon.source.toLowerCase().includes(searchLower))) {
                        return false;
                    }
                }
                
                return true;
            }).map((icon, filteredIndex) => {
                // Find original index for selection purposes
                const originalIndex = iconData.discoveredIcons.findIndex(orig => orig.id === icon.id);
                return { icon, index: originalIndex };
            });
        }

        function populateIcons() {
            // Only count valid, non-deleted, non-archived icons
            const validIcons = iconData.discoveredIcons ? iconData.discoveredIcons.filter(icon => 
                icon && 
                icon.id && 
                icon.page !== '🗄️ Archived Icons' && 
                !icon.name.toLowerCase().startsWith('archive/') && 
                !icon.name.toLowerCase().includes('[archived]')
            ) : [];
            const actualCount = validIcons.length;
            
            if (actualCount === 0) {
                elements.emptyState.style.display = 'block';
                
                if (currentMode === 'library') {
                    elements.emptyState.innerHTML = `
                        <h3>Icon Library is empty</h3>
                        <p>Use "Auto-Create Icon Components" from other pages to populate your library with master components.</p>
                    `;
                } else {
                    elements.emptyState.innerHTML = `
                        <h3>No icons found</h3>
                        <p>Click "Scan for Icons" to discover icons in your Figma file, or add icons manually.</p>
                    `;
                }
                
                elements.iconGrid.style.display = 'none';
                elements.iconList.classList.remove('show');
                elements.scanResults.classList.add('show');
                elements.statusLegend.classList.remove('show');
                
                // Hide details panel when no icons
                elements.detailsPanel.classList.remove('show');
                document.querySelector('.content').classList.remove('with-details');
                return;
            }

            const filteredIcons = getFilteredIcons();
            
            if (filteredIcons.length === 0 && searchFilter) {
                elements.emptyState.style.display = 'block';
                
                if (currentMode === 'library') {
                    elements.emptyState.innerHTML = `
                        <h3>No library components match "${searchFilter}"</h3>
                        <p>Try a different search term or clear the search to show all components.</p>
                    `;
                } else {
                    elements.emptyState.innerHTML = `
                        <h3>No icons match "${searchFilter}"</h3>
                        <p>Try a different search term or clear the search to show all icons.</p>
                    `;
                }
                
                elements.iconGrid.style.display = 'none';
                elements.iconList.classList.remove('show');
                return;
            }

            elements.emptyState.style.display = 'none';
            elements.scanResults.classList.add('show');
            elements.statusLegend.classList.add('show');

            // Group filtered icons by page and then by status
            const iconsByPage = new Map();
            filteredIcons.forEach(({ icon, index }) => {
                // Map old status names to new simplified names
                let status = icon.status;
                if (status === 'in-frame') status = 'unresolved';
                if (status === 'component-instance') status = 'instance';
                if (status === 'master-component') status = 'master';
                
                if (!iconsByPage.has(icon.page)) {
                    iconsByPage.set(icon.page, {
                        master: [],
                        instance: [],
                        unresolved: []
                    });
                }
                iconsByPage.get(icon.page)[status].push({ icon: { ...icon, status }, index });
            });

            // Populate grid with page sections organised by status
            elements.iconGrid.innerHTML = '';
            elements.iconGrid.style.display = 'block';
            
            for (const [pageName, statusGroups] of iconsByPage) {
                // Create page section
                const pageSection = document.createElement('div');
                pageSection.className = 'page-section';
                
                const totalCount = statusGroups.master.length + statusGroups.instance.length + statusGroups.unresolved.length;
                
                // Create page header
                const pageHeader = document.createElement('div');
                pageHeader.className = 'page-header';
                pageHeader.innerHTML = `
                    <div class="page-title">${pageName}</div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div class="page-count">${totalCount} icons</div>
                        <div class="page-toggle">▼</div>
                    </div>
                `;
                
                // Add toggle functionality
                pageHeader.addEventListener('click', (e) => {
                    e.stopPropagation();
                    pageSection.classList.toggle('collapsed');
                });
                
                // Add duplicate consolidation banner for Icon Library page
                let duplicateBanner = null;
                if (pageName === '🎯 Icon Library') {
                    const duplicateIcons = statusGroups.master.filter(({ icon }) => icon.isDuplicate);
                    if (duplicateIcons.length > 0) {
                        duplicateBanner = document.createElement('div');
                        duplicateBanner.className = 'duplicate-banner';
                        duplicateBanner.innerHTML = `
                            <div class="duplicate-banner-content">
                                <div class="duplicate-banner-title">
                            <i data-lucide="alert-triangle" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: text-bottom;"></i>
                            Duplicate Components Detected
                        </div>
                                <div class="duplicate-banner-text">${duplicateIcons.length} duplicate master components found. Consolidate to keep your library clean.</div>
                            </div>
                            <button class="duplicate-banner-button" id="consolidateDupsButton">
                                Consolidate Dups (${duplicateIcons.length})
                            </button>
                        `;
                    }
                }
                
                // Create page content container
                const pageContent = document.createElement('div');
                pageContent.className = 'page-content';
                
                                        // Add status groups in logical order: Master, Instance, Unresolved
                        const statusOrder = [
                            { key: 'master', label: 'MASTER ICONS', color: 'purple' },
                            { key: 'instance', label: 'INSTANCE ICONS', color: 'green' },
                            { key: 'unresolved', label: 'UNRESOLVED ICONS', color: 'orange' }
                        ];
                
                statusOrder.forEach(({ key, label, color }) => {
                    const icons = statusGroups[key];
                    if (icons.length > 0) {
                        // Status subheader
                        const statusHeader = document.createElement('div');
                        statusHeader.style.cssText = `
                            font-size: 11px;
                            font-weight: 600;
                            color: #666;
                            margin: 12px 0 8px 0;
                            padding-bottom: 4px;
                            border-bottom: 1px solid #e6e6e6;
                            display: flex;
                            align-items: center;
                            gap: 6px;
                        `;
                        statusHeader.innerHTML = `
                            <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--${color}-color, ${color === 'purple' ? '#8b5cf6' : color === 'green' ? '#10b981' : '#f59e0b'});"></div>
                            ${label} (${icons.length})
                        `;
                        pageContent.appendChild(statusHeader);
                        
                        // Status icons grid
                        const statusGrid = document.createElement('div');
                        statusGrid.style.cssText = `
                            display: grid;
                            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                            gap: 8px;
                            margin-bottom: 16px;
                        `;
                        
                        icons.forEach(({ icon, index }) => {
                            const slot = document.createElement('div');
                            slot.className = `icon-slot filled status-${icon.status}`;
                            slot.dataset.iconIndex = index;
                            
                            // Create tooltip text
                            let tooltipText = '';
                            if (icon.componentSet && icon.type !== 'COMPONENT_SET') {
                                // Individual variant within a component set or collection
                                if (icon.componentSet === icon.name) {
                                    // This is the parent collection component
                                    const variantCount = iconData.discoveredIcons.filter(i => 
                                        i.componentSet === icon.name && i.id !== icon.id
                                    ).length;
                                    tooltipText = `Icon collection with ${variantCount} individual icons${icon.instanceCount ? ` (${icon.instanceCount} instances)` : ''}`;
                                } else {
                                    // This is an individual variant
                                    tooltipText = `Icon variant from ${icon.componentSet}${icon.instanceCount ? ` (${icon.instanceCount} instances)` : ''}`;
                                }
                            } else {
                            switch (icon.status) {
                                case 'unresolved':
                                    tooltipText = icon.frameContext ? `Unresolved: ${icon.frameContext}` : 'Unresolved';
                                    break;
                                case 'instance':
                                    tooltipText = 'Instance icon';
                                    break;
                                case 'master':
                                        if (icon.type === 'COMPONENT_SET') {
                                            tooltipText = `Component set with ${icon.variants || 0} variants`;
                                        } else if (icon.type === 'COMPONENT' && icon.componentSet === icon.name) {
                                            // This is a collection component
                                            const variantCount = iconData.discoveredIcons.filter(i => 
                                                i.componentSet === icon.name && i.id !== icon.id
                                            ).length;
                                            tooltipText = `Icon collection with ${variantCount} individual icons${icon.instanceCount ? ` (${icon.instanceCount} instances)` : ''}`;
                                        } else {
                                    tooltipText = `Master icon${icon.instanceCount ? ` (${icon.instanceCount} instances)` : ''}`;
                                        }
                                    break;
                                }
                            }
                            
                            // Add tags for new, duplicate, or variant icons
                            let tags = '';
                            if (icon.isNew) {
                                tags += '<div class="icon-tag new">NEW</div>';
                            }
                            // Only show DUP tag on Icon Library page where consolidation happens
                            if (icon.isDuplicate && icon.page === '🎯 Icon Library') {
                                tags += '<div class="icon-tag duplicate">DUP</div>';
                            }
                            // Show variant count for component sets
                            if (icon.type === 'COMPONENT_SET' && icon.variants && icon.variants > 1) {
                                tags += `<div class="icon-tag variants">${icon.variants}V</div>`;
                            }
                            // Show if this is an individual variant within a component set or collection
                            if (icon.componentSet && icon.type !== 'COMPONENT_SET') {
                                tags += '<div class="icon-tag variants">VAR</div>';
                            }
                            // Show collection indicator for large components containing multiple icons
                            if (icon.type === 'COMPONENT' && icon.componentSet === icon.name) {
                                // This is a collection component - count how many variants it has
                                const variantCount = iconData.discoveredIcons.filter(i => 
                                    i.componentSet === icon.name && i.id !== icon.id
                                ).length;
                                if (variantCount > 0) {
                                    tags += `<div class="icon-tag variants">${variantCount + 1}V</div>`;
                                }
                            }
                            
                            if (icon.preview) {
                                // Show actual icon preview with tooltip and background if needed
                                const needsBg = needsBackground(icon.preview);
                                const bgStyle = needsBg ? 'background: #f0f0f0; padding: 2px; border-radius: 4px;' : '';
                                slot.innerHTML = `
                                    <img src="${icon.preview}" 
                                         alt="${icon.name}" 
                                         style="max-width: 48px; max-height: 48px; object-fit: contain; ${bgStyle}">
                                    <div class="tooltip">${tooltipText}</div>
                                    ${tags}
                                `;
                            } else {
                                // Fallback to text if no preview available
                                slot.innerHTML = `
                                    <div style="font-size: 10px; text-align: center; color: #999;">${icon.name.substring(0, 8)}</div>
                                    <div class="tooltip">${tooltipText}</div>
                                    ${tags}
                                `;
                            }
                            
                            slot.addEventListener('click', () => selectIcon(index));
                            slot.addEventListener('contextmenu', (e) => showContextMenu(e, index));
                            statusGrid.appendChild(slot);
                        });
                        
                        // Add "add more" slot ONLY for master icons section on Icon Library page
                        if (key === 'master' && currentPageName === '🎯 Icon Library') {
                            const addSlot = document.createElement('div');
                            addSlot.className = 'icon-slot';
                            addSlot.innerHTML = `
                                <div class="add-icon-slot">+</div>
                                <div class="tooltip">Add a new icon to your library</div>
                            `;
                            addSlot.addEventListener('click', () => {
                                showAddIconModal();
                            });
                            statusGrid.appendChild(addSlot);
                        }
                        
                        pageContent.appendChild(statusGrid);
                    }
                });
                
                pageSection.appendChild(pageHeader);
                
                // Add duplicate banner if it exists
                if (duplicateBanner) {
                    pageSection.appendChild(duplicateBanner);
                    // Add event listener for the consolidate button
                    const consolidateBtn = duplicateBanner.querySelector('#consolidateDupsButton');
                    if (consolidateBtn) {
                        consolidateBtn.addEventListener('click', () => {
                            if (iconData.scanComplete && isOnIconLibraryPage()) {
                                showConsolidateDupsDialog();
                            }
                        });
                    }
                }
                
                pageSection.appendChild(pageContent);
                elements.iconGrid.appendChild(pageSection);
            }

            // Note: Add icon button is now only shown in master icons section of Icon Library page

            // Populate list (also grouped by page and status)
            elements.iconList.innerHTML = '';
            for (const [pageName, statusGroups] of iconsByPage) {
                const totalCount = statusGroups.master.length + statusGroups.instance.length + statusGroups.unresolved.length;
                
                // Page header for list view
                const listPageHeader = document.createElement('div');
                listPageHeader.className = 'list-page-header';
                listPageHeader.style.cssText = `
                    padding: 8px;
                    background: #f8f9fa;
                    border-bottom: 1px solid #e6e6e6;
                    font-size: 12px;
                    font-weight: 600;
                    color: #666;
                `;
                listPageHeader.textContent = `${pageName} (${totalCount} icons)`;
                elements.iconList.appendChild(listPageHeader);
                
                // Add icons by status groups in logical order
                const statusOrder = [
                    { key: 'master', label: 'MASTER ICONS' },
                    { key: 'instance', label: 'INSTANCE ICONS' },
                    { key: 'unresolved', label: 'UNRESOLVED ICONS' }
                ];
                
                statusOrder.forEach(({ key, label }) => {
                    const icons = statusGroups[key];
                    if (icons.length > 0) {
                        // Status subheader for list
                        const statusSubheader = document.createElement('div');
                        statusSubheader.style.cssText = `
                            padding: 4px 8px;
                            background: #f0f0f0;
                            font-size: 10px;
                            font-weight: 600;
                            color: #888;
                            text-transform: uppercase;
                            letter-spacing: 0.5px;
                        `;
                        statusSubheader.textContent = `${label} (${icons.length})`;
                        elements.iconList.appendChild(statusSubheader);
                        
                        icons.forEach(({ icon, index }) => {
                            const item = document.createElement('div');
                            item.className = 'list-item';
                            item.dataset.iconIndex = index;
                            
                            const iconPreview = icon.preview 
                                ? (() => {
                                    const needsBg = needsBackground(icon.preview);
                                    const bgStyle = needsBg ? 'background: #f0f0f0; padding: 1px; border-radius: 2px;' : '';
                                    return `<img src="${icon.preview}" style="width: 100%; height: 100%; object-fit: contain; ${bgStyle}" alt="${icon.name}">`;
                                })()
                                : '<div style="background: #f0f0f0; width: 100%; height: 100%; border-radius: 2px;"></div>';
                                
                            item.innerHTML = `
                                <div class="list-icon">${iconPreview}</div>
                                <div class="list-name">${icon.name}</div>
                            `;
                            item.addEventListener('click', () => selectIcon(index));
                            item.addEventListener('contextmenu', (e) => showContextMenu(e, index));
                            elements.iconList.appendChild(item);
                        });
                    }
                });
            }

            switchView(currentView);
        }

        function selectIcon(index) {
            selectedIcon = iconData.discoveredIcons[index];
            
            // Update selection in UI
            document.querySelectorAll('.icon-slot, .list-item').forEach(el => {
                el.classList.remove('selected');
            });
            
            document.querySelectorAll(`[data-icon-index="${index}"]`).forEach(el => {
                el.classList.add('selected');
            });

            // Show details panel
            elements.detailsPanel.classList.add('show');
            document.querySelector('.content').classList.add('with-details');
            
            // Update details
            elements.selectedIconName.textContent = selectedIcon.name;
            elements.iconSize.textContent = `${Math.floor(selectedIcon.width)} × ${Math.floor(selectedIcon.height)}`;
            elements.iconSource.textContent = selectedIcon.frameContext ? `Found in ${selectedIcon.frameContext}` : selectedIcon.source;
            
            // Enhanced type display for component sets, collections, and variants
            if (selectedIcon.type === 'COMPONENT_SET') {
                const variantText = selectedIcon.variants ? ` (${selectedIcon.variants} variants)` : '';
                elements.iconType.textContent = `Component Set${variantText}`;
            } else if (selectedIcon.componentSet && selectedIcon.componentSet !== selectedIcon.name) {
                // This is an individual variant within a component set or collection
                elements.iconType.textContent = `Icon Variant (from ${selectedIcon.componentSet})`;
            } else if (selectedIcon.type === 'COMPONENT' && selectedIcon.componentSet === selectedIcon.name) {
                // This is an icon collection component
                const variantCount = iconData.discoveredIcons.filter(i => 
                    i.componentSet === selectedIcon.name && i.id !== selectedIcon.id
                ).length;
                elements.iconType.textContent = `Icon Collection (${variantCount} individual icons)`;
            } else {
                elements.iconType.textContent = selectedIcon.type;
            }
            
            elements.iconPage.textContent = selectedIcon.page;
            
            // Show/hide variant selector
            showVariantSelector();
            
            // Update status message
            const statusElement = document.getElementById('iconStatus');
            if (statusElement) {
                let statusMessage = '';
                let statusClass = 'icon-status';
                
                switch (selectedIcon.status) {
                    case 'master':
                        statusMessage = `This is a master icon component${selectedIcon.instanceCount ? ` with ${selectedIcon.instanceCount} instances` : ''}.`;
                        statusClass += ' master-status';
                        break;
                    case 'instance':
                        statusMessage = 'This is an instance of a master component. <a href="#" id="addToLibrary">Go to master</a>';
                        statusClass += ' instance-status';
                        break;
                    case 'unresolved':
                    default:
                        statusMessage = 'This icon is unresolved. <a href="#" id="addToLibrary">Add to icon library</a>';
                        statusClass += ' unresolved-status';
                        break;
                }
                
                statusElement.className = statusClass;
                statusElement.innerHTML = statusMessage;
            }
            
            // Update preview in details panel
            if (selectedIcon.preview) {
                elements.iconPreview.innerHTML = createIconWithBackground(selectedIcon.preview, selectedIcon.name);
            } else {
                elements.iconPreview.innerHTML = '<div style="color: #999; font-size: 10px;">No preview</div>';
            }
            
            // Select icon on canvas (only if not already selecting from canvas)
            if (!isSelectingFromCanvas) {
                parent.postMessage({ 
                    pluginMessage: { 
                        type: 'select-icon',
                        iconId: selectedIcon.id 
                    } 
                }, '*');
            }
        }

        function showVariantSelector() {
            const variantSelector = document.getElementById('variantSelector');
            const variantTabs = document.getElementById('variantTabs');
            const variantCount = document.getElementById('variantCount');
            
            // Check if this icon has variants
            if (selectedIcon && selectedIcon.variantData && selectedIcon.variantData.length > 1) {
                variantSelector.style.display = 'block';
                variantCount.textContent = `${selectedIcon.variantData.length} variants`;
                
                // Clear existing tabs
                variantTabs.innerHTML = '';
                
                // Create variant tabs (performance optimized)
                selectedIcon.variantData.forEach((variant, index) => {
                    const tab = document.createElement('div');
                    tab.className = 'variant-tab';
                    tab.dataset.variantIndex = index.toString();
                    if (index === 0) tab.classList.add('active'); // First variant is active by default
                    
                    // Show preview if available, otherwise show placeholder
                    if (variant.preview) {
                        const needsBg = needsBackground(variant.preview);
                        const bgStyle = needsBg ? 'background: #f0f0f0; padding: 2px; border-radius: 3px;' : '';
                        tab.innerHTML = `
                            <img src="${variant.preview}" alt="${variant.name}" style="max-width: 24px; max-height: 24px; object-fit: contain; ${bgStyle}">
                            <div class="tooltip">${variant.name} (${Math.floor(variant.width)}×${Math.floor(variant.height)})</div>
                        `;
                    } else {
                        // Show placeholder that will be replaced when preview loads
                        tab.innerHTML = `
                            <div class="variant-placeholder" style="font-size: 8px; color: #999; display: flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #f0f0f0; border-radius: 3px;">${variant.name.substring(0, 2).toUpperCase()}</div>
                            <div class="tooltip">${variant.name} (${variant.width}×${variant.height})</div>
                        `;
                    }
                    
                    tab.addEventListener('click', () => {
                        selectVariant(variant, index);
                    });
                    
                    variantTabs.appendChild(tab);
                });
            } else {
                variantSelector.style.display = 'none';
            }
        }

        function selectVariant(variant, index) {
            // Update active tab
            document.querySelectorAll('.variant-tab').forEach((tab, i) => {
                tab.classList.toggle('active', i === index);
            });
            
            // If variant has preview, show it immediately
            if (variant.preview) {
                elements.iconPreview.innerHTML = createIconWithBackground(variant.preview, variant.name);
            } else {
                // Show loading state and request preview generation
                elements.iconPreview.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999; font-size: 11px;">
                        Loading preview...
                    </div>
                `;
                
                // Request preview generation from backend
                parent.postMessage({
                    pluginMessage: {
                        type: 'generate-variant-preview',
                        variantId: variant.id
                    }
                }, '*');
            }
            
            // Update size display to show variant size
            elements.iconSize.textContent = `${Math.floor(variant.width)} × ${Math.floor(variant.height)}`;
            
            // Select variant on canvas
            if (!isSelectingFromCanvas) {
                parent.postMessage({ 
                    pluginMessage: { 
                        type: 'select-icon',
                        iconId: variant.id 
                    } 
                }, '*');
            }
        }

        function selectIconById(iconId) {
            const index = iconData.discoveredIcons.findIndex(icon => icon.id === iconId);
            if (index !== -1) {
                selectIcon(index);
            }
        }

        function setButtonLoading(button, loading = true) {
            if (!button) {
                console.warn('setButtonLoading called with null button');
                return;
            }
            
            if (loading) {
                button.disabled = true;
                if (button.classList.contains('primary')) {
                    button.textContent = 'Scanning...';
                    button.style.background = '#6b7280';
                } else {
                    button.textContent = 'Scanning...';
                    button.classList.add('active');
                }
            } else {
                button.disabled = false;
                if (button.classList.contains('primary')) {
                    button.textContent = 'Scan for Icons';
                    button.style.background = '';
                } else {
                    button.textContent = 'Scan for Icons';
                    button.classList.remove('active');
                }
            }
        }

        function resetAllScanButtons(loading = false) {
            const headerScanButton = document.getElementById('headerScanButton');
            if (headerScanButton) {
                setButtonLoading(headerScanButton, loading);
            }
            if (elements.scanButton) {
                setButtonLoading(elements.scanButton, loading);
            }
        }

        // Auto-Replace Dialog Functions
        function showAutoReplaceDialog() {
            const dialog = document.getElementById('autoReplaceDialog');
            const currentPageNameDialog = document.getElementById('currentPageNameDialog');
            
            // Update current page name in dialog
            currentPageNameDialog.textContent = currentPageName || 'This page';
            
            // Calculate impact preview
            updateImpactPreview('current-page');
            
            // Show dialog
            dialog.classList.add('show');
        }

        function hideAutoReplaceDialog() {
            const dialog = document.getElementById('autoReplaceDialog');
            dialog.classList.remove('show');
        }

        function updateImpactPreview(scope) {
            const replaceableIconsEl = document.getElementById('replaceableIcons');
            const newComponentsEl = document.getElementById('newComponents');
            
            if (!iconData.discoveredIcons) {
                replaceableIconsEl.textContent = '0';
                newComponentsEl.textContent = '0';
                return;
            }
            
            let iconPool = iconData.discoveredIcons;
            
            // Filter by scope
            if (scope === 'current-page' && currentPageName) {
                iconPool = iconData.discoveredIcons.filter(icon => icon.page === currentPageName);
            }
            
            // Count unresolved icons that can be replaced
            const replaceableIcons = iconPool.filter(icon => 
                icon.status === 'unresolved' || icon.status === 'in-frame'
            ).length;
            
            // Estimate new components (unique icons by normalized name + size)
            const uniqueIconKeys = new Set();
            iconPool.forEach(icon => {
                if (icon.status === 'unresolved' || icon.status === 'in-frame') {
                    const normalizedName = icon.name.toLowerCase()
                        .replace(/[-_\s\.]/g, '')
                        .replace(/\d+/g, '')
                        .replace(/(icon|svg|vector|graphic|outline|filled|solid)/g, '')
                        .replace(/[^a-z]/g, '');
                    const sizeGroup = `${Math.round(icon.width/8)*8}x${Math.round(icon.height/8)*8}`;
                    const key = `${normalizedName}_${sizeGroup}_${icon.source}`;
                    uniqueIconKeys.add(key);
                }
            });
            
            replaceableIconsEl.textContent = replaceableIcons;
            newComponentsEl.textContent = uniqueIconKeys.size;
        }

        function selectScopeOption(selectedScope) {
            // Update visual selection
            document.querySelectorAll('.scope-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelector(`[data-scope="${selectedScope}"]`).classList.add('selected');
            
            // Update impact preview
            updateImpactPreview(selectedScope);
        }

        function executeAutoReplace() {
            const selectedScope = document.querySelector('.scope-option.selected').dataset.scope;
            
            // Hide dialog
            hideAutoReplaceDialog();
            
            // Show loading state
            elements.consolidateButton.disabled = true;
            elements.consolidateButton.textContent = 'Replacing...';
            
            // Send consolidation request with scope
            parent.postMessage({ 
                pluginMessage: { 
                    type: 'consolidate-icons',
                    icons: iconData.discoveredIcons,
                    scope: selectedScope,
                    currentPageName: currentPageName
                } 
            }, '*');
        }

        // Success Dialog Functions
        function showSuccessDialog(message) {
            const dialog = document.getElementById('successDialog');
            const successMessage = document.getElementById('successMessage');
            
            successMessage.textContent = message;
            dialog.classList.add('show');
        }

        function hideSuccessDialog() {
            const dialog = document.getElementById('successDialog');
            dialog.classList.remove('show');
        }

        function triggerRefreshScan() {
            // Hide success dialog
            hideSuccessDialog();
            
            // Stop existing timer before starting new scan
            stopNewStatusCleanupTimer();
            
            // Trigger a new scan with safe button handling
            const headerScanButton = document.getElementById('headerScanButton');
            if (headerScanButton) {
                setButtonLoading(headerScanButton, true);
            }
            if (elements.scanButton) {
                setButtonLoading(elements.scanButton, true);
            }
            
            showProgress(true);
            updateProgress(0);
            
            parent.postMessage({ 
                pluginMessage: { type: 'scan-icons' } 
            }, '*');
        }

        // Consolidate Dups Dialog Functions
        function showConsolidateDupsDialog() {
            const dialog = document.getElementById('consolidateDupsDialog');
            const duplicateCountEl = document.getElementById('duplicateCount');
            const keepCountEl = document.getElementById('keepCount');
            
            if (!iconData.discoveredIcons || !isOnIconLibraryPage()) {
                return;
            }
            
            // Get duplicates on the Icon Library page
            const libraryIcons = iconData.discoveredIcons.filter(icon => icon.page === currentPageName);
            const duplicates = libraryIcons.filter(icon => icon.isDuplicate);
            
            // Calculate how many unique icons we'll keep vs remove
            const duplicateGroups = new Map();
            duplicates.forEach(icon => {
                const basePattern = icon.name.toLowerCase()
                    .replace(/[-_\s\.]/g, '')
                    .replace(/\d+/g, '')
                    .replace(/\s*copy\s*\d*/i, '')
                    .trim();
                const sizeKey = `${icon.width}x${icon.height}`;
                const groupKey = `${basePattern}_${sizeKey}`;
                
                if (!duplicateGroups.has(groupKey)) {
                    duplicateGroups.set(groupKey, []);
                }
                duplicateGroups.get(groupKey).push(icon);
            });
            
            // Count: keep 1 per group, remove the rest
            let toKeep = duplicateGroups.size;
            let toRemove = duplicates.length - toKeep;
            
            duplicateCountEl.textContent = toRemove;
            keepCountEl.textContent = toKeep;
            
            dialog.classList.add('show');
        }

        function hideConsolidateDupsDialog() {
            const dialog = document.getElementById('consolidateDupsDialog');
            dialog.classList.remove('show');
        }

        function executeConsolidateDups() {
            // Hide dialog
            hideConsolidateDupsDialog();
            
            // Show loading state on banner button
            const bannerButton = document.getElementById('consolidateDupsButton');
            if (bannerButton) {
                bannerButton.disabled = true;
                bannerButton.textContent = 'Consolidating...';
            }
            
            // Send consolidation request
            parent.postMessage({ 
                pluginMessage: { 
                    type: 'consolidate-library-duplicates',
                    icons: iconData.discoveredIcons,
                    currentPageName: currentPageName
                } 
            }, '*');
        }

        // Icon Swap Dialog Functions
        let currentSwapIcon = null;
        let selectedReplacementIcon = null;
        let swapIconsData = [];
        


        function showIconSwapDialog(icon) {
            // Validate input
            if (!icon || !icon.id) {
                showStatus('Error: Invalid icon selected for swapping', 'error');
                return;
            }
            
            currentSwapIcon = icon;
            selectedReplacementIcon = null;
            
            // Update current icon display
            document.getElementById('currentSwapName').textContent = icon.name || 'Unnamed Icon';
            document.getElementById('currentSwapDetails').textContent = `${icon.width || 0}×${icon.height || 0} • ${icon.page || 'Unknown Page'}`;
            
            if (icon.preview) {
                document.getElementById('currentSwapImage').innerHTML = `<img src="${icon.preview}" alt="${icon.name}">`;
            } else {
                document.getElementById('currentSwapImage').innerHTML = '<div class="swap-placeholder">No preview available</div>';
            }
            
            // Reset new icon display
            document.getElementById('newSwapImage').innerHTML = '<div class="swap-placeholder">Select a replacement icon from the grid below</div>';
            document.getElementById('newSwapName').textContent = 'Choose replacement...';
            document.getElementById('newSwapDetails').textContent = 'Select from available icons';
            
            // Get available icons for replacement (exclude current icon and archived icons)
            // Include both master components AND potential icon-like elements
            if (!iconData.discoveredIcons || iconData.discoveredIcons.length === 0) {
                showStatus('No icons available for swapping. Please run a scan first.', 'error');
                return;
            }
            
            swapIconsData = iconData.discoveredIcons.filter(availableIcon => 
                availableIcon && 
                availableIcon.id && 
                availableIcon.id !== icon.id &&
                availableIcon.page !== '🗄️ Archived Icons' && // Exclude anything from archived page
                !availableIcon.name.toLowerCase().startsWith('archive/') && // Exclude archived icons by name pattern
                !availableIcon.name.toLowerCase().includes('[archived]') && // Exclude manually archived items
                (
                    availableIcon.status === 'master' || 
                    availableIcon.status === 'master-component' ||
                    availableIcon.status === 'unresolved' // Include frames, groups, vectors that could be icons
                )
            );
            
            // Populate swap icon grid
            populateSwapIconGrid();
            
            // Reset search
            const searchInput = document.getElementById('swapSearchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            
            // Reset and hide all dynamic sections
            document.getElementById('swapSizing').style.display = 'none';
            document.getElementById('swapConversion').style.display = 'none';
            document.getElementById('swapImpact').style.display = 'none';
            document.getElementById('swapDirectionHint').style.display = 'none';
            
            // Reset button state
            const confirmButton = document.getElementById('confirmIconSwap');
            const buttonText = document.getElementById('swapButtonText');
            if (confirmButton && buttonText) {
                confirmButton.disabled = true;
                buttonText.textContent = 'Select an icon to continue';
            }
            
            // Show dialog
            document.getElementById('iconSwapDialog').classList.add('show');
            
            // Initialize Lucide icons for the swap direction button
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function hideIconSwapDialog() {
            document.getElementById('iconSwapDialog').classList.remove('show');
            currentSwapIcon = null;
            selectedReplacementIcon = null;
            swapIconsData = [];
        }

        function swapDirection() {
            // Can only swap if we have both icons selected
            if (!currentSwapIcon || !selectedReplacementIcon) {
                showStatus('Please select a replacement icon first before swapping direction', 'warning');
                return;
            }
            
            console.log('Swapping direction between:', currentSwapIcon.name, 'and', selectedReplacementIcon.name);
            
            // Add visual feedback to the arrow
            const swapArrow = document.getElementById('swapDirection');
            if (swapArrow) {
                swapArrow.style.transform = 'scale(0.9) rotate(180deg)';
                setTimeout(() => {
                    swapArrow.style.transform = 'scale(1) rotate(180deg)';
                    setTimeout(() => {
                        swapArrow.style.transform = '';
                    }, 200);
                }, 100);
            }
            
            // Store the current icons
            const tempCurrentIcon = currentSwapIcon;
            const tempSelectedIcon = selectedReplacementIcon;
            
            // Swap the icons
            currentSwapIcon = tempSelectedIcon;
            selectedReplacementIcon = tempCurrentIcon;
            
            // Update the current icon display (left side)
            document.getElementById('currentSwapName').textContent = currentSwapIcon.name || 'Unnamed Icon';
            document.getElementById('currentSwapDetails').textContent = `${currentSwapIcon.width || 0}×${currentSwapIcon.height || 0} • ${currentSwapIcon.page || 'Unknown Page'}`;
            
            if (currentSwapIcon.preview) {
                document.getElementById('currentSwapImage').innerHTML = `<img src="${currentSwapIcon.preview}" alt="${currentSwapIcon.name}">`;
            } else {
                document.getElementById('currentSwapImage').innerHTML = '<div class="swap-placeholder">No preview available</div>';
            }
            
            // Update the new icon display (right side)
            const newSwapName = document.getElementById('newSwapName');
            const newSwapDetails = document.getElementById('newSwapDetails');
            const newSwapImage = document.getElementById('newSwapImage');
            
            if (newSwapName) newSwapName.textContent = selectedReplacementIcon.name;
            
            // Add status indicator to details with better formatting
            const statusText = selectedReplacementIcon.status === 'unresolved' ? ' (will be converted)' : ' (ready to use)';
            if (newSwapDetails) {
                newSwapDetails.textContent = `${selectedReplacementIcon.width}×${selectedReplacementIcon.height} • ${selectedReplacementIcon.page}${statusText}`;
            }
            
            if (newSwapImage) {
                if (selectedReplacementIcon.preview) {
                    newSwapImage.innerHTML = `<img src="${selectedReplacementIcon.preview}" alt="${selectedReplacementIcon.name}">`;
                } else {
                    newSwapImage.innerHTML = '<div class="swap-placeholder">No preview available</div>';
                }
            }
            
            // Update visual selection in the grid to reflect the new selectedReplacementIcon
            document.querySelectorAll('.swap-icon-slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            
            const selectedSlot = Array.from(document.querySelectorAll('.swap-icon-slot')).find(slot => 
                slot.dataset.iconId === selectedReplacementIcon.id
            );
            if (selectedSlot) {
                selectedSlot.classList.add('selected');
            }
            
            // Update dynamic sections (sizing, conversion, impact)
            updateSwapSections();
            
            showStatus(`Swapped direction! Now replacing "${currentSwapIcon.name}" with "${selectedReplacementIcon.name}"`, 'success');
        }

        function updateSwapSections() {
            if (!currentSwapIcon || !selectedReplacementIcon) return;
            
            // Show/hide conversion notice for non-components
            const conversionEl = document.getElementById('swapConversion');
            if (conversionEl) {
                if (selectedReplacementIcon.status === 'unresolved') {
                    conversionEl.style.display = 'block';
                    
                    // Generate component name for conversion
                    const componentName = `Design System/${selectedReplacementIcon.name}`;
                    const conversionNameEl = document.getElementById('conversionComponentName');
                    if (conversionNameEl) {
                        conversionNameEl.textContent = componentName;
                    }
                } else {
                    conversionEl.style.display = 'none';
                }
            }
            
            // Show/hide sizing controls if dimensions don't match
            const sizingEl = document.getElementById('swapSizing');
            if (sizingEl) {
                const hasSizeDifference = Math.abs(currentSwapIcon.width - selectedReplacementIcon.width) > 2 || 
                                        Math.abs(currentSwapIcon.height - selectedReplacementIcon.height) > 2;
                
                if (hasSizeDifference) {
                    const currentIconSize = document.getElementById('currentIconSize');
                    const replacementIconSize = document.getElementById('replacementIconSize');
                    
                    if (currentIconSize) currentIconSize.textContent = `${currentSwapIcon.width}×${currentSwapIcon.height}`;
                    if (replacementIconSize) replacementIconSize.textContent = `${selectedReplacementIcon.width}×${selectedReplacementIcon.height}`;
                    
                    sizingEl.style.display = 'block';
                    
                    // Intelligent default selection based on size comparison
                    const currentArea = currentSwapIcon.width * currentSwapIcon.height;
                    const replacementArea = selectedReplacementIcon.width * selectedReplacementIcon.height;
                    const shouldScaleToFit = replacementArea > currentArea * 1.5;
                    
                    const scaleRadio = document.querySelector('input[value="scale-to-fit"]');
                    const keepRadio = document.querySelector('input[value="keep-original"]');
                    
                    if (scaleRadio && keepRadio) {
                        if (shouldScaleToFit) {
                            scaleRadio.checked = true;
                        } else {
                            keepRadio.checked = true;
                        }
                    }
                } else {
                    sizingEl.style.display = 'none';
                }
            }
            
            // Calculate and show impact
            calculateSwapImpact();
            
            // Update button text and ensure it's enabled
            const confirmButton = document.getElementById('confirmIconSwap');
            const buttonText = document.getElementById('swapButtonText');
            
            if (confirmButton && buttonText) {
                if (selectedReplacementIcon.status === 'unresolved') {
                    buttonText.textContent = 'Convert & Swap Icons';
                } else {
                    buttonText.textContent = 'Swap Icons';
                }
                
                confirmButton.disabled = false;
            }
            
            // Ensure the swap direction hint stays visible
            const hintElement = document.getElementById('swapDirectionHint');
            if (hintElement) {
                hintElement.style.display = 'flex';
            }
        }

        function populateSwapIconGrid() {
            const swapIconGrid = document.getElementById('swapIconGrid');
            const swapIconCount = document.getElementById('swapIconCount');
            
            if (!swapIconGrid || !swapIconCount) {
                console.error('Swap icon grid elements not found');
                return;
            }
            
            swapIconGrid.innerHTML = '';
            
            if (!swapIconsData || swapIconsData.length === 0) {
                swapIconCount.textContent = 'No icons available';
                swapIconGrid.innerHTML = `
                    <div class="swap-empty-state">
                        <h4>No replacement options found</h4>
                        <p>Try running a scan first to discover more icons and components in your file.</p>
                    </div>
                `;
                return;
            }
            
            // Update status bar
            const componentCount = swapIconsData.filter(icon => icon && icon.status !== 'unresolved').length;
            const needsConversionCount = swapIconsData.filter(icon => icon && icon.status === 'unresolved').length;
            
            swapIconCount.textContent = `${swapIconsData.length} options available`;
            
            swapIconsData.forEach((icon, index) => {
                if (!icon || !icon.id) {
                    console.warn(`Skipping invalid icon at index ${index}:`, icon);
                    return;
                }
                
                try {
                    const slot = document.createElement('div');
                    slot.className = 'swap-icon-slot';
                    slot.dataset.iconId = icon.id;
                    
                    // Add visual indicator for status
                    if (icon.status === 'unresolved') {
                        slot.classList.add('needs-conversion');
                    }
                    
                    // Restore selection state if this is the currently selected replacement
                    if (selectedReplacementIcon && selectedReplacementIcon.id === icon.id) {
                        slot.classList.add('selected');
                    }
                    
                    // Create status indicator with better icons
                    const statusIndicator = icon.status === 'unresolved' 
                        ? '<div class="swap-status-badge">📦</div>' 
                        : '<div class="swap-status-badge component">✓</div>';
                    
                    // Create detailed tooltip with safe values
                    const iconName = icon.name || 'Unnamed';
                    const iconWidth = icon.width || 0;
                    const iconHeight = icon.height || 0;
                    const iconPage = icon.page || 'Unknown';
                    
                    const tooltipText = icon.status === 'unresolved' 
                        ? `${iconName}\n${iconWidth}×${iconHeight} • ${iconPage}\nWill be converted to master component`
                        : `${iconName}\n${iconWidth}×${iconHeight} • ${iconPage}\nReady to use as-is`;
                    
                    if (icon.preview) {
                        slot.innerHTML = `
                            <img src="${icon.preview}" alt="${iconName}" style="max-width: 52px; max-height: 52px; object-fit: contain;">
                            ${statusIndicator}
                            <div class="tooltip">${tooltipText}</div>
                        `;
                    } else {
                        slot.innerHTML = `
                            <div style="font-size: 9px; color: #999; text-align: center; padding: 4px;">${iconName.substring(0, 6)}</div>
                            ${statusIndicator}
                            <div class="tooltip">${tooltipText}</div>
                        `;
                    }
                    
                    slot.addEventListener('click', () => {
                        selectReplacementIcon(icon);
                    });
                    swapIconGrid.appendChild(slot);
                    
                } catch (error) {
                    console.error(`Error creating slot for icon ${icon.name}:`, error);
                }
            });
        }

        function selectReplacementIcon(icon) {
            try {
                selectedReplacementIcon = icon;
                
                // Update visual selection
                document.querySelectorAll('.swap-icon-slot').forEach(slot => {
                    slot.classList.remove('selected');
                });
                
                // Use safer approach to find slot by ID (escaping special characters)
                const selectedSlot = Array.from(document.querySelectorAll('.swap-icon-slot')).find(slot => 
                    slot.dataset.iconId === icon.id
                );
                if (selectedSlot) {
                    selectedSlot.classList.add('selected');
                }
                
                // Update new icon display
                const newSwapName = document.getElementById('newSwapName');
                const newSwapDetails = document.getElementById('newSwapDetails');
                const newSwapImage = document.getElementById('newSwapImage');
                
                if (newSwapName) newSwapName.textContent = icon.name;
                
                // Add status indicator to details with better formatting
                const statusText = icon.status === 'unresolved' ? ' (will be converted)' : ' (ready to use)';
                if (newSwapDetails) {
                    newSwapDetails.textContent = `${icon.width}×${icon.height} • ${icon.page}${statusText}`;
                }
                
                if (newSwapImage) {
                    if (icon.preview) {
                        newSwapImage.innerHTML = `<img src="${icon.preview}" alt="${icon.name}">`;
                    } else {
                        newSwapImage.innerHTML = '<div class="swap-placeholder">No preview available</div>';
                    }
                }
                
                // Show/hide conversion notice for non-components
                const conversionEl = document.getElementById('swapConversion');
                if (conversionEl) {
                    if (icon.status === 'unresolved') {
                        conversionEl.style.display = 'block';
                        
                        // Generate component name for conversion (use a fallback since figma object isn't available in UI)
                        const componentName = `Design System/${icon.name}`;
                        const conversionNameEl = document.getElementById('conversionComponentName');
                        if (conversionNameEl) {
                            conversionNameEl.textContent = componentName;
                        }
                    } else {
                        conversionEl.style.display = 'none';
                    }
                }
                
                // Show/hide sizing controls if dimensions don't match
                const sizingEl = document.getElementById('swapSizing');
                if (sizingEl && currentSwapIcon) {
                    const hasSizeDifference = Math.abs(currentSwapIcon.width - icon.width) > 2 || 
                                            Math.abs(currentSwapIcon.height - icon.height) > 2;
                    
                    if (hasSizeDifference) {
                        const currentIconSize = document.getElementById('currentIconSize');
                        const replacementIconSize = document.getElementById('replacementIconSize');
                        
                        if (currentIconSize) currentIconSize.textContent = `${currentSwapIcon.width}×${currentSwapIcon.height}`;
                        if (replacementIconSize) replacementIconSize.textContent = `${icon.width}×${icon.height}`;
                        
                        sizingEl.style.display = 'block';
                        
                        // Intelligent default selection based on size comparison
                        const currentArea = currentSwapIcon.width * currentSwapIcon.height;
                        const replacementArea = icon.width * icon.height;
                        const shouldScaleToFit = replacementArea > currentArea * 1.5; // Scale down if replacement is significantly larger
                        
                        const scaleRadio = document.querySelector('input[value="scale-to-fit"]');
                        const keepRadio = document.querySelector('input[value="keep-original"]');
                        
                        if (scaleRadio && keepRadio) {
                            if (shouldScaleToFit) {
                                scaleRadio.checked = true;
                            } else {
                                keepRadio.checked = true;
                            }
                        }
                    } else {
                        sizingEl.style.display = 'none';
                    }
                }
                
                // Calculate and show impact
                calculateSwapImpact();
                
                // Update button text and enable
                const confirmButton = document.getElementById('confirmIconSwap');
                const buttonText = document.getElementById('swapButtonText');
                
                if (confirmButton && buttonText) {
                    if (icon.status === 'unresolved') {
                        buttonText.textContent = 'Convert & Swap Icons';
                    } else {
                        buttonText.textContent = 'Swap Icons';
                    }
                    
                    confirmButton.disabled = false;
                }
                
                // Show the swap direction hint now that both icons are selected
                const hintElement = document.getElementById('swapDirectionHint');
                if (hintElement) {
                    hintElement.style.display = 'flex';
                    
                    // Re-initialize Lucide icons for the hint lightbulb
                    if (typeof lucide !== 'undefined') {
                        lucide.createIcons();
                    }
                }
                
            } catch (error) {
                showStatus('Error selecting replacement icon: ' + error.message, 'error');
            }
        }

        function calculateSwapImpact() {
            if (!currentSwapIcon || !selectedReplacementIcon) return;
            
            // Calculate instances that would be affected
            // Include the master itself plus all its instances
            let instancesCount = 1; // The master component itself
            const affectedPages = new Set();
            affectedPages.add(currentSwapIcon.page); // Page containing the master
            
            iconData.discoveredIcons.forEach(icon => {
                // Only count non-archived instances
                if (icon.masterComponentId === currentSwapIcon.id && 
                    icon.page !== '🗄️ Archived Icons' && 
                    !icon.name.toLowerCase().startsWith('archive/') && 
                    !icon.name.toLowerCase().includes('[archived]')) {
                    instancesCount++;
                    affectedPages.add(icon.page);
                }
            });
            
            // Update impact display with better context
            document.getElementById('swapInstanceCount').textContent = instancesCount;
            document.getElementById('swapPageCount').textContent = affectedPages.size;
            
            // Show the impact section
            document.getElementById('swapImpact').style.display = 'block';
        }

        function filterSwapIcons(searchTerm) {
            if (!swapIconsData || swapIconsData.length === 0) {
                console.warn('No swap icons data available for filtering');
                return;
            }
            
            const searchLower = (searchTerm || '').toLowerCase().trim();
            const filtered = swapIconsData.filter(icon => 
                icon && 
                icon.name &&
                icon.name.toLowerCase().includes(searchLower) &&
                icon.page !== '🗄️ Archived Icons' && // Exclude archived page
                !icon.name.toLowerCase().startsWith('archive/') && // Exclude archived by name
                !icon.name.toLowerCase().includes('[archived]') // Exclude manually archived
            );
            
            const swapIconGrid = document.getElementById('swapIconGrid');
            const swapIconCount = document.getElementById('swapIconCount');
            
            if (!swapIconGrid || !swapIconCount) {
                console.error('Swap grid elements not found during filtering');
                return;
            }
            
            swapIconGrid.innerHTML = '';
            
            if (filtered.length === 0) {
                const message = searchLower ? `No results for "${searchTerm}"` : 'No icons available';
                swapIconCount.textContent = message;
                swapIconGrid.innerHTML = `
                    <div class="swap-empty-state">
                        <h4>No icons match "${searchTerm}"</h4>
                        <p>Try a different search term or browse all available icons.</p>
                    </div>
                `;
                return;
            }
            
            // Update count with search context
            if (searchLower) {
                swapIconCount.textContent = `${filtered.length} of ${swapIconsData.length} icons found`;
            } else {
                swapIconCount.textContent = `${swapIconsData.length} options available`;
            }
            
            filtered.forEach(icon => {
                const slot = document.createElement('div');
                slot.className = 'swap-icon-slot';
                slot.dataset.iconId = icon.id;
                
                // Add visual indicator for status
                if (icon.status === 'unresolved') {
                    slot.classList.add('needs-conversion');
                }
                
                if (selectedReplacementIcon && selectedReplacementIcon.id === icon.id) {
                    slot.classList.add('selected');
                }
                
                // Create status indicator with better icons
                const statusIndicator = icon.status === 'unresolved' 
                    ? '<div class="swap-status-badge">📦</div>' 
                    : '<div class="swap-status-badge component">✓</div>';
                
                // Create detailed tooltip
                const tooltipText = icon.status === 'unresolved' 
                    ? `${icon.name}\n${icon.width}×${icon.height} • ${icon.page}\nWill be converted to master component`
                    : `${icon.name}\n${icon.width}×${icon.height} • ${icon.page}\nReady to use as-is`;
                
                if (icon.preview) {
                    slot.innerHTML = `
                        <img src="${icon.preview}" alt="${icon.name}">
                        ${statusIndicator}
                        <div class="tooltip">${tooltipText}</div>
                    `;
                } else {
                    slot.innerHTML = `
                        <div style="font-size: 9px; color: #999; text-align: center; padding: 4px;">${icon.name.substring(0, 6)}</div>
                        ${statusIndicator}
                        <div class="tooltip">${tooltipText}</div>
                    `;
                }
                
                slot.addEventListener('click', () => {
                    selectReplacementIcon(icon);
                });
                swapIconGrid.appendChild(slot);
            });
        }

        function executeIconSwap() {
            if (!currentSwapIcon || !currentSwapIcon.id) {
                showStatus('Error: No original icon selected or invalid icon data', 'error');
                return;
            }
            
            if (!selectedReplacementIcon || !selectedReplacementIcon.id) {
                showStatus('Error: Please select a replacement icon first', 'error');
                return;
            }
            
            // Additional validation
            if (currentSwapIcon.id === selectedReplacementIcon.id) {
                showStatus('Error: Cannot swap an icon with itself', 'error');
                return;
            }
            
            // Get sizing preference
            const sizingMode = document.querySelector('input[name="sizingMode"]:checked')?.value || 'scale-to-fit';
            const isConversion = selectedReplacementIcon.status === 'unresolved';
            
            // Store the icon references BEFORE hiding the dialog (which clears the variables)
            const originalIconRef = { ...currentSwapIcon }; // Create a deep copy to avoid reference issues
            const replacementIconRef = { ...selectedReplacementIcon };
            
            // Validate references have required properties
            if (!originalIconRef.id || !replacementIconRef.id) {
                showStatus('Error: Invalid icon data - missing required properties', 'error');
                return;
            }
            
            // Hide dialog
            hideIconSwapDialog();
            
            // Show loading state
            const statusMessage = isConversion ? 'Converting to component and swapping icons...' : 'Swapping icons...';
            showStatus(statusMessage, 'info');
            
            // Send swap request using the stored references
            const swapMessage = {
                type: 'swap-icons',
                originalIcon: originalIconRef,
                replacementIcon: replacementIconRef,
                sizingMode: sizingMode,
                needsConversion: isConversion
            };
            
            // Final validation of the message
            if (!swapMessage.originalIcon?.id || !swapMessage.replacementIcon?.id) {
                showStatus('Error: Invalid swap request - missing icon data', 'error');
                console.error('Invalid swap message:', swapMessage);
                return;
            }
            
            try {
                parent.postMessage({ 
                    pluginMessage: swapMessage
                }, '*');
            } catch (error) {
                showStatus('Error: Failed to send swap request - ' + error.message, 'error');
                console.error('Swap message error:', error);
            }
        }

        // Add Icon Modal Functions
        let selectedSvgFile = null;
        let svgPreviewData = null;

        function showAddIconModal() {
            console.log('Opening add icon modal');
            
            const modal = document.getElementById('addIconModal');
            if (!modal) {
                console.error('Add icon modal element not found');
                showStatus('Modal not found - please refresh the plugin', 'error');
                return;
            }
            
            console.log('Add icon modal opened - sizes are informational only');
            
            // Reset modal state
            resetAddIconModal();
            
            // Show modal
            modal.classList.add('show');
            console.log('Add icon modal opened');
        }

        function hideAddIconModal() {
            const modal = document.getElementById('addIconModal');
            modal.classList.remove('show');
            resetAddIconModal();
        }

        function resetAddIconModal() {
            console.log('Resetting add icon modal');
            
            selectedSvgFile = null;
            svgPreviewData = null;
            
            console.log('Reset: selectedSvgFile and svgPreviewData set to null');
            
            // Reset UI elements
            document.getElementById('addIconPreview').style.display = 'none';
            document.getElementById('confirmAddIcon').disabled = true;
            
            // Reset drop zone
            const dropZone = document.getElementById('dropZone');
            dropZone.classList.remove('drag-over');
            
            // Reset file input
            document.getElementById('fileInput').value = '';
            
            // Clear preview content
            const previewIcon = document.getElementById('previewIcon');
            if (previewIcon) {
                previewIcon.innerHTML = '';
            }
            
            console.log('Add icon modal reset complete');
        }

        function handleFileSelect(file) {
            // More lenient file validation - check extension and MIME type
            const fileName = file.name.toLowerCase();
            const isSvgFile = fileName.endsWith('.svg') || 
                             file.type === 'image/svg+xml' || 
                             file.type === 'text/xml' ||
                             file.type === 'application/xml';
            
            if (!file || !isSvgFile) {
                showStatus('Please select a valid SVG file (.svg extension)', 'error');
                return;
            }
            
            console.log('Selected file:', file.name, 'Type:', file.type, 'Size:', file.size);
            selectedSvgFile = file;
            
            // Read and preview the SVG
            const reader = new FileReader();
            reader.onload = function(e) {
                const svgContent = e.target.result;
                console.log('SVG content length:', svgContent.length);
                console.log('SVG content preview:', svgContent.substring(0, 200));
                previewSvgFile(file, svgContent);
            };
            reader.onerror = function(e) {
                console.error('FileReader error:', e);
                showStatus('Error reading SVG file', 'error');
            };
            reader.readAsText(file);
        }

        function previewSvgFile(file, svgContent) {
            try {
                console.log('Parsing SVG file:', file.name);
                console.log('SVG content type:', typeof svgContent);
                console.log('SVG content (first 500 chars):', svgContent.substring(0, 500));
                
                // Validate SVG content
                if (!svgContent || typeof svgContent !== 'string') {
                    throw new Error('Invalid SVG content - content is empty or not a string');
                }
                
                if (!svgContent.trim().toLowerCase().includes('<svg')) {
                    throw new Error('Invalid SVG content - no <svg> tag found');
                }
                
                // Parse SVG to get dimensions
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
                
                // Check for parsing errors
                const parseError = svgDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error('SVG parsing error: ' + parseError.textContent);
                }
                
                const svgElement = svgDoc.querySelector('svg');
                
                console.log('Parsed SVG element:', svgElement);
                console.log('SVG attributes:', svgElement ? Array.from(svgElement.attributes).map(a => `${a.name}="${a.value}"`).join(', ') : 'none');
                
                if (!svgElement) {
                    throw new Error('No <svg> element found in the document');
                }
                
                // Get dimensions with better parsing
                let width = svgElement.getAttribute('width');
                let height = svgElement.getAttribute('height');
                
                console.log('Initial dimensions from attributes:', { width, height });
                
                // Try viewBox if width/height not available
                if (!width || !height) {
                    const viewBox = svgElement.getAttribute('viewBox');
                    console.log('ViewBox attribute:', viewBox);
                    if (viewBox) {
                        const viewBoxParts = viewBox.split(/\s+/);
                        if (viewBoxParts.length >= 4) {
                            width = width || viewBoxParts[2];
                            height = height || viewBoxParts[3];
                            console.log('Dimensions from viewBox:', { width, height });
                        }
                    }
                }
                
                // Clean up dimensions (remove units like 'px', 'pt', etc.)
                const originalWidth = width;
                const originalHeight = height;
                width = width ? parseInt(width.toString().replace(/[^0-9.]/g, '')) || 24 : 24;
                height = height ? parseInt(height.toString().replace(/[^0-9.]/g, '')) || 24 : 24;
                
                console.log('Dimension conversion:', { 
                    original: { width: originalWidth, height: originalHeight },
                    final: { width, height }
                });
                
                // Store preview data
                svgPreviewData = {
                    content: svgContent,
                    width: width,
                    height: height,
                    fileName: file.name
                };
                
                console.log('Created svgPreviewData:', svgPreviewData);
                
                // Update preview UI
                document.getElementById('previewName').textContent = file.name;
                document.getElementById('previewSize').textContent = `${width}×${height}`;
                
                // Show SVG preview - wrap in a container for better display
                const previewIcon = document.getElementById('previewIcon');
                try {
                    previewIcon.innerHTML = `<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">${svgContent}</div>`;
                    console.log('SVG preview rendered successfully');
                } catch (renderError) {
                    console.warn('Failed to render SVG preview:', renderError);
                    previewIcon.innerHTML = '<div style="color: #666; font-size: 10px; text-align: center; padding: 8px;">Preview not available</div>';
                }
                
                // Show preview section
                document.getElementById('addIconPreview').style.display = 'block';
                
                // Enable confirm button
                document.getElementById('confirmAddIcon').disabled = false;
                
                console.log('SVG preview setup complete. svgPreviewData:', svgPreviewData);
                
            } catch (error) {
                console.error('Error in previewSvgFile:', error);
                console.error('Error stack:', error.stack);
                
                // Reset preview data on error
                svgPreviewData = null;
                
                // Hide preview section
                document.getElementById('addIconPreview').style.display = 'none';
                
                // Disable confirm button
                document.getElementById('confirmAddIcon').disabled = true;
                
                showStatus('Error parsing SVG file: ' + error.message, 'error');
            }
        }

        function executeAddIcon() {
            console.log('executeAddIcon called');
            console.log('selectedSvgFile:', selectedSvgFile);
            console.log('svgPreviewData:', svgPreviewData);
            
            if (!selectedSvgFile) {
                showStatus('No SVG file selected. Please select a file first.', 'error');
                return;
            }
            
            if (!svgPreviewData) {
                showStatus('SVG preview data is missing. Please try selecting the file again.', 'error');
                console.error('svgPreviewData is null - SVG parsing may have failed');
                return;
            }
            
            if (!svgPreviewData.content) {
                showStatus('SVG content is missing. Please try selecting the file again.', 'error');
                console.error('svgPreviewData.content is missing:', svgPreviewData);
                return;
            }
            
            console.log('Executing add icon with data:', svgPreviewData);
            
            // IMPORTANT: Store the data in local variables BEFORE hiding the modal
            // because hideAddIconModal() calls resetAddIconModal() which sets svgPreviewData = null
            const iconData = {
                content: svgPreviewData.content,
                fileName: svgPreviewData.fileName,
                width: svgPreviewData.width,
                height: svgPreviewData.height
            };
            
            console.log('Stored icon data locally:', iconData);
            
            // Hide modal (this will reset svgPreviewData to null)
            hideAddIconModal();
            
            // Show loading state
            showStatus('Adding icon to library...', 'info');
            
            // Use the original SVG size as the target size (no user selection needed)
            const messageData = {
                type: 'add-icon-to-library',
                svgContent: iconData.content,
                fileName: iconData.fileName,
                width: iconData.width,
                height: iconData.height,
                expectedSize: { width: iconData.width, height: iconData.height }
            };
            
            console.log('Sending message to backend:', messageData);
            
            // Send add icon request
            parent.postMessage({
                pluginMessage: messageData
            }, '*');
        }

        // Event Listeners
        elements.searchInput.addEventListener('input', (e) => {
            searchFilter = e.target.value.trim();
            populateIcons(); // Re-populate with search filter automatically as user types
        });

        // Close details panel
        document.getElementById('closeDetails').addEventListener('click', () => {
            elements.detailsPanel.classList.remove('show');
            document.querySelector('.content').classList.remove('with-details');
            
            // Clear selection
            document.querySelectorAll('.icon-slot, .list-item').forEach(el => {
                el.classList.remove('selected');
            });
            selectedIcon = null;
        });

        // Swap icon button
        document.getElementById('swapIconButton').addEventListener('click', () => {
            if (selectedIcon) {
                showIconSwapDialog(selectedIcon);
            }
        });



        elements.viewButtons.forEach(btn => {
            btn.addEventListener('click', () => switchView(btn.dataset.view));
        });

        // Header scan button event listener
        document.getElementById('headerScanButton').addEventListener('click', () => {
            // Stop existing timer before starting new scan
            stopNewStatusCleanupTimer();
            
            const headerScanButton = document.getElementById('headerScanButton');
            setButtonLoading(headerScanButton);
            showProgress(true);
            updateProgress(0);
            
            parent.postMessage({ 
                pluginMessage: { type: 'scan-icons' } 
            }, '*');
        });

        // Legacy scan button (if it exists)
        if (elements.scanButton) {
            elements.scanButton.addEventListener('click', () => {
                // Stop existing timer before starting new scan
                stopNewStatusCleanupTimer();
                
                setButtonLoading(elements.scanButton);
                showProgress(true);
                updateProgress(0);
                
                parent.postMessage({ 
                    pluginMessage: { type: 'scan-icons' } 
                }, '*');
            });
        }

        elements.consolidateButton.addEventListener('click', () => {
            if (iconData.scanComplete) {
                showAutoReplaceDialog();
            }
        });



        // Dialog Event Listeners
        document.querySelectorAll('.scope-option').forEach(option => {
            option.addEventListener('click', () => {
                selectScopeOption(option.dataset.scope);
            });
        });

        document.getElementById('cancelReplace').addEventListener('click', () => {
            hideAutoReplaceDialog();
        });

        document.getElementById('confirmReplace').addEventListener('click', () => {
            executeAutoReplace();
        });

        // Close dialog when clicking overlay
        document.getElementById('autoReplaceDialog').addEventListener('click', (e) => {
            if (e.target.id === 'autoReplaceDialog') {
                hideAutoReplaceDialog();
            }
        });

        // Success Dialog Event Listeners
        document.getElementById('refreshAndScan').addEventListener('click', () => {
            triggerRefreshScan();
        });

        document.getElementById('skipRefresh').addEventListener('click', () => {
            hideSuccessDialog();
        });

        document.getElementById('closeSuccess').addEventListener('click', () => {
            hideSuccessDialog();
        });

        // Close success dialog when clicking overlay
        document.getElementById('successDialog').addEventListener('click', (e) => {
            if (e.target.id === 'successDialog') {
                hideSuccessDialog();
            }
        });

        // Consolidate Dups Dialog Event Listeners
        document.getElementById('cancelConsolidateDups').addEventListener('click', () => {
            hideConsolidateDupsDialog();
        });

        document.getElementById('confirmConsolidateDups').addEventListener('click', () => {
            executeConsolidateDups();
        });

        // Close consolidate dups dialog when clicking overlay
        document.getElementById('consolidateDupsDialog').addEventListener('click', (e) => {
            if (e.target.id === 'consolidateDupsDialog') {
                hideConsolidateDupsDialog();
            }
        });

        // Icon Swap Dialog Event Listeners
        document.getElementById('cancelIconSwap').addEventListener('click', () => {
            hideIconSwapDialog();
        });

        document.getElementById('confirmIconSwap').addEventListener('click', () => {
            if (!selectedReplacementIcon || !selectedReplacementIcon.id) {
                showStatus('Error: No replacement icon selected', 'error');
                return;
            }
            
            if (!currentSwapIcon || !currentSwapIcon.id) {
                showStatus('Error: No original icon selected', 'error');
                return;
            }
            
            executeIconSwap();
        });

        // Close icon swap dialog when clicking overlay
        document.getElementById('iconSwapDialog').addEventListener('click', (e) => {
            if (e.target.id === 'iconSwapDialog') {
                hideIconSwapDialog();
            }
        });

        // Swap search input
        document.getElementById('swapSearchInput').addEventListener('input', (e) => {
            filterSwapIcons(e.target.value);
        });

        // Swap direction button
        document.getElementById('swapDirection').addEventListener('click', () => {
            swapDirection();
        });

        // Onboarding event listeners
        document.getElementById('onboardingNext').addEventListener('click', nextOnboardingStep);
        document.getElementById('onboardingSkip').addEventListener('click', skipOnboarding);
        document.getElementById('onboardingClose').addEventListener('click', skipOnboarding);



        // Settings event listeners
        document.getElementById('settingsButton').addEventListener('click', showSettingsModal);
        document.getElementById('settingsClose').addEventListener('click', hideSettingsModal);
        document.getElementById('replayTutorial').addEventListener('click', () => {
            hideSettingsModal();
            showOnboarding();
        });
        document.getElementById('bulkExportIcons').addEventListener('click', () => {
            if (!iconData.discoveredIcons || iconData.discoveredIcons.length === 0) {
                showToast('No Icons Found', 'Please scan for icons first before exporting.', 'warning', 5000);
                return;
            }
            
            // Filter to get all master icons from any page
            const masterIcons = iconData.discoveredIcons.filter(icon => 
                icon.status === 'master' || icon.type === 'COMPONENT' || icon.type === 'COMPONENT_SET'
            );
            
            if (masterIcons.length === 0) {
                showToast('No Master Icons Found', 'No master icons found. Use Auto-Replace to create master components or ensure you have component sets in your file.', 'warning', 6000);
                return;
            }
            
            // Show breakdown by page for transparency
            const pageBreakdown = {};
            masterIcons.forEach(icon => {
                pageBreakdown[icon.page] = (pageBreakdown[icon.page] || 0) + 1;
            });
            
            const pageList = Object.entries(pageBreakdown)
                .map(([page, count]) => `${page} (${count} icon${count > 1 ? 's' : ''})`)
                .join(', ');
            
            hideSettingsModal();
            showToast('Starting Export...', `Preparing to export ${masterIcons.length} master icon${masterIcons.length > 1 ? 's' : ''} from: ${pageList}`, 'info', 4000);
            
            parent.postMessage({ 
                pluginMessage: { 
                    type: 'bulk-export-icons',
                    icons: masterIcons
                } 
            }, '*');
        });

        // Close settings modal when clicking outside
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') {
                hideSettingsModal();
            }
        });

        // Add Icon Modal event listeners
        document.getElementById('addIconClose').addEventListener('click', hideAddIconModal);
        document.getElementById('cancelAddIcon').addEventListener('click', hideAddIconModal);
        document.getElementById('confirmAddIcon').addEventListener('click', executeAddIcon);

        // File input and drop zone functionality
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        // Click to browse
        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        // File input change
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFileSelect(file);
            }
        });

        // Drag and drop functionality
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
            console.log('Drag over detected');
        });

        dropZone.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
            console.log('Drag enter detected');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            // Only remove drag-over if we're leaving the drop zone completely
            if (!dropZone.contains(e.relatedTarget)) {
                dropZone.classList.remove('drag-over');
                console.log('Drag leave detected');
            }
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
            
            console.log('Drop detected, files:', e.dataTransfer.files.length);
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                console.log('Processing dropped file:', files[0].name, files[0].type);
                handleFileSelect(files[0]);
            } else {
                console.log('No files found in drop event');
                showStatus('No files detected. Please try again.', 'error');
            }
        });



        // Close add icon modal when clicking outside
        document.getElementById('addIconModal').addEventListener('click', (e) => {
            if (e.target.id === 'addIconModal') {
                hideAddIconModal();
            }
        });

        // Add to icon library functionality (for single icons)
        function addSingleIconToLibrary() {
            if (!selectedIcon) {
                showToast('No Icon Selected', 'Please select an icon first before adding it to the library.', 'warning', 5000);
                return;
            }
            
            if (selectedIcon.status !== 'unresolved') {
                showToast('Icon Already Organised', 'This icon is already part of your organised library.', 'info', 5000);
                return;
            }
            
            // Show loading state
            showToast('Converting Icon...', `Converting "${selectedIcon.name}" to a master component in your Icon Library.`, 'info', 3000);
            
            // Send convert single icon request
            parent.postMessage({
                pluginMessage: {
                    type: 'convert-single-icon',
                    icon: selectedIcon
                }
            }, '*');
        }

        // Handle dynamic "Add to library" links
        document.addEventListener('click', (e) => {
            if (e.target && e.target.id === 'addToLibrary') {
                e.preventDefault();
                addSingleIconToLibrary();
            }
        });

        // Handle messages from plugin
        window.addEventListener('message', (event) => {
            const { type, data } = event.data.pluginMessage || {};

            switch (type) {
                case 'scan-progress':
                    updateProgress(data.percentage);
                    break;
                    
                case 'page-changed-scanning':
                    // Show that we're automatically scanning due to page change
                    showProgress(true);
                    updateProgress(0);
                    setButtonLoading(elements.scanButton);
                    showStatus(data.message, 'info');
                    
                    // Update page name immediately
                    if (data.newPageName) {
                        currentPageName = data.newPageName;
                        updateMode(); // Update mode based on new page
                    }
                    break;

                case 'scan-complete':
                    iconData = { ...iconData, ...data, scanComplete: true };
                    
                    // Add timestamps to any new icons
                    if (iconData.discoveredIcons) {
                        iconData.discoveredIcons.forEach(icon => {
                            if (icon.isNew && !icon.newTimestamp) {
                                markIconAsNew(icon);
                            }
                        });
                    }
                    
                    // Update current page name and mode
                    if (data.currentPageName) {
                        currentPageName = data.currentPageName;
                        updateMode(); // This will update UI and stats based on mode
                    }
                    
                    showProgress(false);
                    
                    // Reset both scan buttons
                    const headerScanBtn = document.getElementById('headerScanButton');
                    if (headerScanBtn) {
                        setButtonLoading(headerScanBtn, false);
                    }
                    if (elements.scanButton) {
                        setButtonLoading(elements.scanButton, false);
                    }
                    
                    // Only enable consolidate button if there are unresolved icons
                    const allIcons = iconData.discoveredIcons ? iconData.discoveredIcons.filter(icon => 
                        icon && 
                        icon.id && 
                        icon.page !== '🗄️ Archived Icons' && 
                        !icon.name.toLowerCase().startsWith('archive/') && 
                        !icon.name.toLowerCase().includes('[archived]')
                    ) : [];
                    const unresolvedCount = allIcons.filter(icon => icon.status === 'unresolved' || icon.status === 'in-frame').length;
                    
                    elements.consolidateButton.disabled = unresolvedCount === 0;
                    
                    // Show appropriate status message based on mode and scan type
                    const validIcons = iconData.discoveredIcons ? iconData.discoveredIcons.filter(icon => 
                        icon && 
                        icon.id && 
                        icon.page !== '🗄️ Archived Icons' && 
                        !icon.name.toLowerCase().startsWith('archive/') && 
                        !icon.name.toLowerCase().includes('[archived]')
                    ) : [];
                    const isAutoScan = data.autoScan;
                    const autoScanPrefix = isAutoScan ? `Page "${currentPageName}": ` : '';
                    
                    if (currentMode === 'library') {
                        const libraryIcons = validIcons.filter(icon => icon.page === currentPageName);
                        const duplicateCount = libraryIcons.filter(icon => icon.isDuplicate).length;
                        
                        if (libraryIcons.length > 0) {
                            if (duplicateCount > 0) {
                                                        showStatus(`✨ ${autoScanPrefix}Scan complete! Found ${libraryIcons.length} components with ${duplicateCount} duplicates ready to consolidate`, 'success');
                    } else {
                        showStatus(`✅ ${autoScanPrefix}Scan complete! Found ${libraryIcons.length} components - your library is perfectly organised!`, 'success');
                            }
                        } else {
                            showStatus(`📋 ${autoScanPrefix}Scan complete! Icon Library is empty - use Auto-Replace from other pages to populate it`, 'info');
                        }
                    } else {
                        const unresolvedCount = validIcons.filter(icon => icon.status === 'unresolved' || icon.status === 'in-frame').length;
                        const masterCount = validIcons.filter(icon => icon.status === 'master' || icon.status === 'master-component').length;
                        
                        if (allIcons.length > 0) {
                            if (unresolvedCount > 0) {
                                showStatus(`🎯 ${autoScanPrefix}Scan complete! Found ${allIcons.length} icons (${masterCount} organised, ${unresolvedCount} ready for auto-replace)`, 'success');
                            } else {
                                showStatus(`✅ ${autoScanPrefix}Scan complete! All ${allIcons.length} icons are perfectly organised in your design system!`, 'success');
                            }
                        } else {
                            showStatus(`📋 ${autoScanPrefix}Scan complete! No icons found on this page - try scanning other pages or add some icons`, 'info');
                        }
                    }
                    
                    // Start cleanup timer for new status expiry
                    startNewStatusCleanupTimer();
                    
                    populateIcons();
                    break;

                case 'scan-error':
                    showProgress(false);
                    
                    // Reset both scan buttons
                    const headerScanButton2 = document.getElementById('headerScanButton');
                    if (headerScanButton2) {
                        setButtonLoading(headerScanButton2, false);
                    }
                    if (elements.scanButton) {
                        setButtonLoading(elements.scanButton, false);
                    }
                    
                    showStatus('Error scanning icons: ' + (data.error || 'Unknown error'), 'error');
                    break;



                case 'consolidation-complete':
                    elements.consolidateButton.disabled = false;
                    elements.consolidateButton.textContent = 'Auto-Create Icon Components';
                    
                    // Mark any newly created components as "new" with timestamp
                    if (data.newMasterComponents && iconData.discoveredIcons) {
                        data.newMasterComponents.forEach(newComponentId => {
                            const icon = iconData.discoveredIcons.find(icon => icon.id === newComponentId);
                            if (icon) {
                                markIconAsNew(icon);
                            }
                        });
                        
                        // Refresh UI to show new tags
                        populateIcons();
                    }
                    
                    // Show success toast and dialog with refresh prompt
                    if (data.componentsCreated > 0) {
                        const iconsReplaced = data.iconsReplaced || 0;
                        const pagesAffected = data.pagesAffected || 0;
                        
                        // Toast notification
                        let toastMessage = `Created ${data.componentsCreated} new master component${data.componentsCreated > 1 ? 's' : ''}`;
                        if (iconsReplaced > 0) {
                            toastMessage += ` and replaced ${iconsReplaced} unresolved icon${iconsReplaced > 1 ? 's' : ''}`;
                        }
                        if (pagesAffected > 0) {
                            toastMessage += ` across ${pagesAffected} page${pagesAffected > 1 ? 's' : ''}`;
                        }
                        toastMessage += '. Your design system is now more organised!';
                        
                        showToast('Auto-Replace Complete! 🎉', toastMessage, 'success', 6000);
                        
                        // Success dialog for refresh option
                        let successMessage = `🎉 Auto-Replace complete! Created ${data.componentsCreated} new master component${data.componentsCreated > 1 ? 's' : ''}`;
                        if (iconsReplaced > 0) {
                            successMessage += ` and replaced ${iconsReplaced} unresolved icon${iconsReplaced > 1 ? 's' : ''}`;
                        }
                        if (pagesAffected > 0) {
                            successMessage += ` across ${pagesAffected} page${pagesAffected > 1 ? 's' : ''}`;
                        }
                        successMessage += '. Your design system is now more organised!';
                        
                        showSuccessDialog(successMessage);
                    } else {
                        showToast('Auto-Replace Complete', 'No unresolved icons were found to replace. Your icons are already well organised!', 'warning', 5000);
                    }
                    break;

                case 'consolidation-error':
                    elements.consolidateButton.disabled = false;
                    elements.consolidateButton.textContent = 'Auto-Create Icon Components';
                    
                    const consolidationError = data.error || 'Unknown error occurred';
                    const humanConsolidationError = getHumanErrorMessage(consolidationError);
                    
                    showToast(
                        'Auto-Replace Failed',
                        humanConsolidationError,
                        'error',
                        8000
                    );
                    
                    console.error('Auto-replace technical error:', consolidationError);
                    break;

                case 'library-consolidation-complete':
                    // Re-populate to update banner state
                    populateIcons();
                    
                    if (data.duplicatesRemoved > 0) {
                        if (data.errors && data.errors > 0) {
                            // Show partial success with error details
                            const errorSummary = data.errorDetails && data.errorDetails.length > 0 
                                ? `\n\nErrors: ${data.errorDetails.slice(0, 3).join(', ')}${data.errorDetails.length > 3 ? '...' : ''}`
                                : '';
                            
                            showToast(
                                'Partial Success ⚠️',
                                `Consolidated ${data.duplicatesRemoved} duplicate${data.duplicatesRemoved > 1 ? 's' : ''} but encountered ${data.errors} error${data.errors > 1 ? 's' : ''}.${errorSummary}`,
                                'warning',
                                8000
                            );
                            console.error('Consolidation errors:', data.errorDetails);
                        } else {
                            const duplicatesRemoved = data.duplicatesRemoved;
                            const toastMessage = `Removed ${duplicatesRemoved} duplicate component${duplicatesRemoved > 1 ? 's' : ''} from your Icon Library. Your library is now cleaner and more organised!`;
                            
                            showToast('Library Consolidation Complete! 🧹', toastMessage, 'success', 6000);
                            
                            const successMessage = `🧹 Library consolidation complete! Removed ${duplicatesRemoved} duplicate component${duplicatesRemoved > 1 ? 's' : ''} from your Icon Library. Your library is now cleaner and more organised!`;
                            showSuccessDialog(successMessage);
                        }
                    } else {
                        if (data.errors && data.errors > 0) {
                            showToast(
                                'Consolidation Failed',
                                `${data.errors} errors occurred during consolidation. Your library may have locked components or permission issues.`,
                                'error',
                                8000
                            );
                            console.error('Consolidation errors:', data.errorDetails);
                        } else {
                            showToast(
                                'Library Already Organised ✅',
                                'No duplicates were found - your library is already perfectly organised!',
                                'success',
                                5000
                            );
                        }
                    }
                    break;

                case 'library-consolidation-error':
                    // Re-populate to update banner state
                    populateIcons();
                    
                    const libraryError = data.error || 'Unknown error occurred';
                    const humanLibraryError = getHumanErrorMessage(libraryError);
                    
                    showToast(
                        'Library Consolidation Failed',
                        humanLibraryError,
                        'error',
                        8000
                    );
                    
                    console.error('Library consolidation technical error:', libraryError);
                    break;

                case 'canvas-selection-changed':
                    if (data.nodeId && iconData.discoveredIcons) {
                        isSelectingFromCanvas = true;
                        selectIconById(data.nodeId);
                        setTimeout(() => {
                            isSelectingFromCanvas = false;
                        }, 100);
                    }
                    break;

                case 'icon-renamed':
                    showStatus(data.message || 'Icon renamed successfully', 'success');
                    
                    // Update the icon in our data if it exists
                    if (iconData.discoveredIcons && selectedIcon && selectedIcon.id === data.iconId) {
                        selectedIcon.name = data.newName;
                        elements.selectedIconName.textContent = data.newName;
                        
                        // Update in discoveredIcons array
                        const iconIndex = iconData.discoveredIcons.findIndex(icon => icon.id === data.iconId);
                        if (iconIndex !== -1) {
                            iconData.discoveredIcons[iconIndex].name = data.newName;
                            populateIcons(); // Refresh the grid to show new name
                        }
                    }
                    break;

                case 'rename-error':
                    showStatus('Error renaming icon: ' + (data.error || 'Unknown error'), 'error');
                    break;

                case 'relaunch-set':
                    showStatus(data.message || 'Right-click the icon and select "Rename" to use Figma AI', 'info');
                    break;

                case 'relaunch-error':
                    showStatus('Error setting up Figma AI rename: ' + (data.error || 'Unknown error'), 'error');
                    break;

                case 'icon-swap-complete':
                    const swapMessage = data.message || 'Icons swapped successfully';
                    const instancesUpdated = data.instancesUpdated || 0;
                    const pagesAffected = data.pagesAffected || 0;
                    const converted = data.converted || false;
                    const newComponentName = data.newComponentName || 'new component';
                    
                    // Create success toast with detailed information
                    let toastTitle = 'Icon Swap Successful! 🎉';
                    let toastMessage = '';
                    
                    if (converted) {
                        toastMessage = `Converted "${newComponentName}" to a master component and `;
                    }
                    
                    if (instancesUpdated > 0) {
                        toastMessage += `replaced ${instancesUpdated} instance${instancesUpdated > 1 ? 's' : ''}`;
                        if (pagesAffected > 0) {
                            toastMessage += ` across ${pagesAffected} page${pagesAffected > 1 ? 's' : ''}`;
                        }
                    } else {
                        toastMessage += 'completed the swap operation';
                    }
                    
                    toastMessage += '. All icon properties and positioning have been preserved.';
                    
                    showToast(toastTitle, toastMessage, 'success', 6000);
                    
                    // Refresh the scan to update the UI with new state
                    setTimeout(() => {
                        setButtonLoading(elements.scanButton);
                        showProgress(true);
                        updateProgress(0);
                        
                        parent.postMessage({ 
                            pluginMessage: { type: 'scan-icons' } 
                        }, '*');
                    }, 1500); // Slightly longer delay to let user read the success message
                    break;

                case 'icon-swap-error':
                    const errorMessage = data.error || 'Unknown error occurred';
                    const humanError = getHumanErrorMessage(errorMessage);
                    
                    showToast(
                        'Icon Swap Failed',
                        humanError,
                        'error',
                        8000 // Longer duration for error messages
                    );
                    
                    // Also log the technical error for debugging
                    console.error('Icon swap technical error:', errorMessage);
                    break;

                case 'onboarding-state':
                    onboardingCompleted = data.completed || false;
                    // Show onboarding if not completed and not already shown
                    if (!onboardingCompleted && !document.getElementById('onboardingOverlay').classList.contains('show')) {
                        setTimeout(() => {
                            showOnboarding();
                        }, 1000); // Show onboarding after 1 second
                    }
                    break;

                case 'add-icon-complete':
                    const iconName = data.iconName || 'new icon';
                    showToast(
                        'Icon Added Successfully! 🎉',
                        `"${iconName}" has been added to your Icon Library and is ready to use across your design system.`,
                        'success',
                        6000
                    );
                    
                    // Refresh the scan to show the new icon
                    setTimeout(() => {
                        // Use header scan button as primary reference
                        const headerScanButton = document.getElementById('headerScanButton');
                        if (headerScanButton) {
                            setButtonLoading(headerScanButton, true);
                        }
                        if (elements.scanButton) {
                            setButtonLoading(elements.scanButton, true);
                        }
                        
                        showProgress(true);
                        updateProgress(0);
                        showStatus('Refreshing to show new icon...', 'info');
                        
                        parent.postMessage({ 
                            pluginMessage: { type: 'scan-icons' } 
                        }, '*');
                    }, 1500); // Slightly longer delay to let user see success message
                    break;

                case 'add-icon-error':
                    const addIconError = data.error || 'Unknown error occurred';
                    const humanAddIconError = getHumanErrorMessage(addIconError);
                    
                    showToast(
                        'Failed to Add Icon',
                        humanAddIconError,
                        'error',
                        8000
                    );
                    
                    console.error('Add icon technical error:', addIconError);
                    break;

                case 'bulk-export-complete':
                    const exportedCount = data.exportedCount || 0;
                    const exportData = data.exportData;
                    
                    if (exportData && exportData.icons) {
                        // Create and download individual SVG files
                        downloadExportedIcons(exportData);
                        
                        showToast(
                            'Export Complete! 📁',
                            `Successfully exported ${exportedCount} icon${exportedCount > 1 ? 's' : ''} as SVG files. Check your downloads folder!`,
                            'success',
                            8000
                        );
                    } else {
                        showToast(
                            'Export Complete! 📁',
                            `Successfully exported ${exportedCount} icon${exportedCount > 1 ? 's' : ''}, but download data is missing.`,
                            'warning',
                            8000
                        );
                    }
                    break;

                case 'bulk-export-error':
                    const exportError = data.error || 'Unknown error occurred';
                    const humanExportError = getHumanErrorMessage(exportError);
                    
                    showToast(
                        'Export Failed',
                        humanExportError,
                        'error',
                        8000
                    );
                    
                    console.error('Bulk export technical error:', exportError);
                    break;

                case 'single-icon-convert-complete':
                    const convertedIconName = data.iconName || 'icon';
                    showToast(
                        'Icon Converted! 🎉',
                        `"${convertedIconName}" has been converted to a master component and added to your Icon Library.`,
                        'success',
                        6000
                    );
                    
                    // Refresh the scan to show the updated icon status
                    setTimeout(() => {
                        const headerScanButton = document.getElementById('headerScanButton');
                        if (headerScanButton) {
                            setButtonLoading(headerScanButton, true);
                        }
                        
                        showProgress(true);
                        updateProgress(0);
                        showStatus('Refreshing to show converted icon...', 'info');
                        
                        parent.postMessage({ 
                            pluginMessage: { type: 'scan-icons' } 
                        }, '*');
                    }, 1500);
                    break;

                case 'single-icon-convert-error':
                    const convertError = data.error || 'Unknown error occurred';
                    const humanConvertError = getHumanErrorMessage(convertError);
                    
                    // Add helpful suggestions based on error type
                    let convertErrorMessage = humanConvertError;
                    const errorStr = convertError.toLowerCase();
                    
                    if (errorStr.includes('not found') || errorStr.includes('no longer accessible') || errorStr.includes('corrupted')) {
                        convertErrorMessage += '\n\nTry clicking the refresh button (🔄) to update the icon list with the latest data.';
                    }
                    
                    showToast(
                        'Failed to Convert Icon',
                        convertErrorMessage,
                        'error',
                        10000 // Show longer for complex errors
                    );
                    
                    console.error('Single icon convert technical error:', convertError);
                    console.error('Icon ID:', data.iconId, 'Icon Name:', data.iconName);
                    break;

                case 'variant-preview-generated':
                    if (selectedIcon && selectedIcon.variantData && data.variantId && data.preview) {
                        // Find the variant in the current selected icon's variant data
                        const variant = selectedIcon.variantData.find(v => v.id === data.variantId);
                        if (variant) {
                            // Update the variant preview
                            variant.preview = data.preview;
                            
                            // Update the variant tab preview if visible
                            const variantTab = document.querySelector(`.variant-tab[data-variant-index]`);
                            const variantIndex = selectedIcon.variantData.indexOf(variant);
                            const specificVariantTab = Array.from(document.querySelectorAll('.variant-tab')).find(tab => 
                                tab.dataset.variantIndex === variantIndex.toString()
                            );
                            
                            if (specificVariantTab) {
                                const needsBg = needsBackground(data.preview);
                                const bgStyle = needsBg ? 'background: #f0f0f0; padding: 2px; border-radius: 3px;' : '';
                                specificVariantTab.innerHTML = `
                                    <img src="${data.preview}" alt="${variant.name}" style="max-width: 24px; max-height: 24px; object-fit: contain; ${bgStyle}">
                                    <div class="tooltip">${variant.name} (${Math.floor(variant.width)}×${Math.floor(variant.height)})</div>
                                `;
                            }
                            
                            // If this is the currently active variant, update the main preview too
                            const activeTab = document.querySelector('.variant-tab.active');
                            if (activeTab && activeTab.dataset.variantIndex === variantIndex.toString()) {
                                elements.iconPreview.innerHTML = createIconWithBackground(data.preview, variant.name);
                            }
                        }
                    }
                    break;

                case 'variant-preview-error':
                    if (selectedIcon) {
                        // Show error in the preview area if we were loading a variant
                        elements.iconPreview.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999; font-size: 11px; text-align: center;">
                                Preview unavailable
                            </div>
                        `;
                    }
                    break;
                    
                case 'replace-with-instance-complete':
                    showToast('Replacement Complete', data.message, 'success', 5000);
                    // Refresh the icon list to reflect changes
                    setTimeout(() => {
                        // Show loading state
                        const headerScanButton = document.getElementById('headerScanButton');
                        if (headerScanButton) {
                            setButtonLoading(headerScanButton, true);
                        }
                        
                        showProgress(true);
                        updateProgress(0);
                        showStatus('Refreshing to show replacement...', 'info');
                        
                        parent.postMessage({ 
                            pluginMessage: { type: 'scan-icons' } 
                        }, '*');
                    }, 1000);
                    break;
                    
                case 'replace-with-instance-error':
                    console.error('Replace with instance error:', data);
                    showToast('Replacement Failed', data.error || 'Failed to replace icon with instance', 'error', 5000);
                    break;
            }
        });

        // Removed analytics tracking for privacy

        // Initialize
        updateStats();
        showProgress(false);
        elements.scanResults.classList.add('show');
        updateMode(); // Set initial mode based on current page
        
        // Context Menu Event Listeners
        const setupContextMenuListeners = () => {
            const convertBtn = document.getElementById('contextMenuConvert');
            const replaceBtn = document.getElementById('contextMenuReplace');
            const swapBtn = document.getElementById('contextMenuSwap');
            const selectBtn = document.getElementById('contextMenuSelect');
            
            if (convertBtn) {
                convertBtn.addEventListener('click', handleContextMenuConvert);
            }
            if (replaceBtn) {
                replaceBtn.addEventListener('click', handleContextMenuReplace);
            }
            if (swapBtn) {
                swapBtn.addEventListener('click', handleContextMenuSwap);
            }
            if (selectBtn) {
                selectBtn.addEventListener('click', handleContextMenuSelect);
            }
        };
        
        setupContextMenuListeners();

        // Global click handler to hide context menu
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.context-menu')) {
                hideContextMenu();
            }
        });

        // Prevent context menu from closing when clicking inside it
        document.getElementById('contextMenu').addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Add mousedown event to prevent context menu from disappearing
        document.getElementById('contextMenu').addEventListener('mousedown', (e) => {
            e.stopPropagation();
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close any open dialogs
                hideAutoReplaceDialog();
                hideSuccessDialog();
                hideConsolidateDupsDialog();
                hideIconSwapDialog();
                hideSettingsModal();
                hideAddIconModal();
                hideOnboarding();
                hideContextMenu(); // Also hide context menu on Escape
            }
        });
        
        // Cleanup timer when plugin closes
        window.addEventListener('beforeunload', () => {
            stopNewStatusCleanupTimer();
        });
        
        // Request onboarding state from backend on plugin load
        parent.postMessage({ 
            pluginMessage: { type: 'get-onboarding-state' } 
        }, '*');

        // Auto-scan on plugin open (initial scan)
        setTimeout(() => {
            // Stop any existing timer before auto-scan
            stopNewStatusCleanupTimer();
            
            resetAllScanButtons(true); // Set all scan buttons to loading
            showProgress(true);
            updateProgress(0);
            showStatus('Loading plugin - scanning current page...', 'info');
            
            parent.postMessage({ 
                pluginMessage: { type: 'scan-icons' } 
            }, '*');
        }, 500); // Small delay to ensure UI is ready

        // Initialize Lucide icons
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        });

        // Also initialize if DOM is already loaded
        if (document.readyState === 'loading') {
            // Do nothing, wait for DOMContentLoaded
        } else {
            // DOM already loaded
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }
</script>
</body>
</html>
